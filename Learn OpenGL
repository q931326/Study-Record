Mipmaps：多级渐进纹理，被存储材质的一些缩小版本，根据距离使用材质的合适大小。
欧拉角：偏航角yaw，俯仰角pitch，滚动角roll。
有可能造成万向节死锁，导致原因是因为引擎的坐标实现顺序，
Unity是ZXY，ue是XYZ，由于Z轴先旋转，紧接着Y轴旋转了90°，共360°，造成了x轴和z轴的重合，导致x和z旋转结果一致。

光照：
1.颜色：
2.光照基础：
冯氏光照模型：漫反射+镜面反射+环境光
光能够反射到其他表面，考虑到这种情况的算法叫做全局照明，开销高昂，极其复杂。
将环境光（不提供最明显的光照效果）添加到场景里，用光的颜色*常量环境因子*物体的颜色。
漫反射光照会对物体产生显著的视觉影响。
法向量：使用叉乘的技巧为立方体所有的顶点计算出法线。
gl_Postion （内建的输出变量）= projection(投影矩阵) * view(观察矩阵) * model(模型矩阵) *vec4(position,1.0f);
Normal 顶点法向量。
计算漫反射：
vec3 norm = normalize(Normal); vec3 lightDir = normalize(lightPos - FragPos);
float diff = max(dot(norm,lightDir),0.0); vec3 diffuse  = diff * lightColor;
vec3 result = (ambient + diffuse)*objectColor; color = vec4(result,1.0f);

提交不等比缩放的时候，法向量容易被改变，需要使用正规矩阵。
Normal = mat3(transpose(inverse(model)))*normal;
镜面光照：反射光和视线方向越小，镜面光作用越大。

光照贴图：
漫反射贴图（纹理就是这种）：为每个像素索引独立颜色值。
vec3 diffuse = light.diffuse*diff(漫反射系数)*vec3(texture(material.diffuse,TexCoords(纹理坐标)));
镜面贴图（specular贴图）：更新片段着色器材质属性，接受一个sampler2D作为这个specular部分的类型，而不是vec3

投光物：一个光源把光投射到物体上，叫做投光
定向光：当一个光源很远时，每条光线都是接近于平行，看起来所有的光都来自于同一个方向，独立于光源的位置
点光源：衰减公式：Fatt = 1 / Kc+Kl*d+Kq*d*d；
聚光：LightDir:从片段指向光源的向量，SpotDir：聚光所指向的方向
Phi：定义聚光半径的切光角，Theta，lightdir和spotdir向量之间的角度
多光源，使用for循环来实现。

模型加载库：Assimp，可以把多种不同类型的模型加载到程序中。

深度测试：深度测试函数：可以通过glDepthFunc来设置比较运算符。
深度值精度：Fdepth = (1/z - 1/near)/(1/far-1/near);
NDC深度转换: float z = depth * 2.0 - 1.0；
把所得到的z值应用逆转换来检索的线性深度值：
float linearDepth  = （2.0*near）/（far + near - z * （far - near））；
深度冲突的定义：两个平面或三角形如此紧密相互平行深度缓冲区不具有足够的精度以至于无法得到哪一个靠前
防止深度冲突的几个技巧：1.让物体之间不要离得太近，通过在物体之间制造一点用户无法察觉到的偏移，可以完全解决深度冲突。
2.尽可能把近平面设置得远一些。近平面越靠近，精度越高
3.放弃一些性能来得到更高的深度值的精度。
模板测试：
开启模板缓冲原则：
1.开启模板缓冲写入。2.渲染物体，更新模板缓冲。3.关闭模板缓冲写入。
4.渲染（其他）物体，这次基于模板缓冲内容丢弃特定片段。
模板函数：
void glStencilFunc(GLenum func（设置模板测试操作）, GLint ref（指定模板测试的引用值）, GLuint mask（指定一个遮罩）)
void glStencilOp(GLenum sfail（如果失败将采取的动作）, GLenum dpfail（如果模板测试通过，深度测试失败采取的动作）, GLenum dppass（都通过采取的动作）)

混合：物体透明技术
忽略片段：如果我们导入一个图像，不希望看到方块图像，而只显示实际的纹理像素，剩余的可以被看穿，加载带有alpha值的纹理我们需要告诉
SOIL，加载RGBA图像，而不是RGB图像，SOIL能以RGBA的方式加载大多数没有alpha值的纹理，它会将像素的alpha值设为1.0
unsigned char * image = SOIL_load_image(path, &width, &height, 0, SOIL_LOAD_RGBA);
不要忘记改变openGL生成的纹理：
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, image);
没有清除掉方块图像alpha值的情况，可能是openGL不知道该如何处理，GLSL提供了discard命令，保证了片段不会进一步被处理，这样就不会进入颜色缓冲。
OpenGL混合方程：C¯result=C¯source（源颜色向量）∗Fsource（源因子）+C¯destination（目标颜色向量）∗Fdestination（目标因子）

面剔除：我们可以看一个正方体，无论何种方式和角度，最多看到3个面， 因此可以把另外3个面给丢弃，提高性能。
面剔除做的工作是检查所有正面朝向观察者的面，并渲染他们，丢弃所有背弃朝向的面，OpenGL分析顶点数据的连接顺序来实现。
逆时针的顶点连接顺序被定义为三角形的正面。 glEnable(GL_CULL_FACE);开启面剔除
帧缓冲：将颜色缓冲，深度缓冲，模板缓冲结合起来的叫做帧缓冲。
构建帧缓冲必须满足的条件：
1.我们必须往里面加入至少一个附件（颜色、深度、模板缓冲）。
2.其中至少有一个是颜色附件。
3.所有的附件都应该是已经完全做好的（已经存储在内存之中）。
4.每个缓冲都应该有同样数目的样本。
纹理附件：
如果你打算把整个屏幕渲染到一个或大或小的纹理上，你需要用新的纹理的尺寸作为参数再次调用glViewport（要在渲染到你的帧缓冲之前做好），
否则只有一小部分纹理或屏幕能够绘制到纹理上。
将纹理附加到帧缓冲上：glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,GL_TEXTURE_2D, texture, 0);
1.target：我们所创建的帧缓冲类型的目标（绘制、读取或两者都有）。
2.attachment：我们所附加的附件的类型。现在我们附加的是一个颜色附件。需要注意，最后的那个0是暗示我们可以附加1个以上颜色的附件。我们会在后面的教程中谈到。
3.textarget：你希望附加的纹理类型。
4.texture：附加的实际纹理。
5.level：Mipmap level。我们设置为0。

后期处理：1.反相 用1.0减去屏幕纹理的颜色。2.灰度：获得所有颜色元素，将他们平均化。 
Kernel effects：1.锐化  2.模糊  3.边检测

立方体贴图：将多个纹理组合起来映射到一个单一纹理。
有自己的特有的属性，可以使用方向向量对他们索引和采样。
方向向量的大小无关紧要，一旦提供了方向，openGL就会获取方向向量触碰到立方体的表面上的相应的纹理像素，返回了正确的纹理采样值。
方向向量触碰到立方体表面的一点也就是立方体贴图的纹理位置，只要立方体的中心位于原点上，我们就可以使用立方体的位置向量来对立方体贴图进行采样。
天空盒：最后渲染天空盒能够给我们带来轻微的性能提升。
环境映射：1.反射，2.折射
高级数据：
使用glBufferData函数填充缓冲对象管理的内存，调用glBufferSubData函数填充特定区域的缓冲，而不是一次填充整个缓冲。

几何着色器：可以用到任何物体上，无论多么复杂。
EmitVertex()是一个函数，用于提交或“发射”一个顶点，以供图形管道进一步处理。
实例化：一种只调用一次渲染函数却能绘制出很多物体的技术，节省了从CPU到GPU的时间。
抗锯齿：绘制图形时会出现走样的问题，为了减少走样，产生平滑的边缘就需要抗锯齿技术，也称为反走样，
SSAA超级采样抗锯齿技术，MSAA多采样抗锯齿

高级光照：漫反射部分角度不能大于90°，一旦大于90°，点乘结果就是负数，贡献为0，对于镜面反射，不会测量光线和法线之间的角度
而是测量视线和反射方向向量之间的。
Blinn-Phone改进了Phone模型，原理是放弃了反射向量， 而改用了半程向量，在视线方向和光线方向之间的位置。半程向量和法线
向量越近，镜面反射程度就越大。
Blinn-Phong着色的一个附加好处是，它比Phong着色性能更高，因为我们不必计算更加复杂的反射向量了。
Phong和Blinn-Phong着色之间另一个细微差别是，半程向量和表面法线之间的角度经常会比视线和反射向量之间的夹角更小。

Gamma校正：设备输出亮度 = 电压的Gamma次幂
Gamma也叫灰度系数，每种显示设备都有自己的Gamma值，对于CRT，Gamma通常为2.2
Gamma校正(Gamma Correction)的思路是在最终的颜色输出上应用监视器Gamma的倒数。
基于gamma2.2的颜色空间叫做sRGB颜色空间。
diffuse纹理，这种为物体上色的纹理几乎都是在sRGB空间中的。specular贴图和法线贴图几乎都在线性空间中，所以如果你把它们也配置为sRGB纹理的话，光照就坏掉了。

阴影映射：
视频游戏中用的较多的是阴影贴图，效果不错，较易实现。
实时渲染非常消耗性能，我们可以使用深度缓冲，管储存在纹理中的所有这些深度值，叫做深度贴图或阴影贴图。根据深度判断是否处于阴影之中。
深度贴图：
阴影失真：阴影贴图受限于解析度，可以使用阴影偏移来解决这个问题。
有可能会产生悬浮的问题，可以使用正面剔除的办法解决，无论正面还是背面都无问题，背面深度不会有错误，因为阴影在物体内部，有错误也看不见。
采样过多：光的视锥不可见的区域一律被认为是处于阴影中，不管他真的处于阴影中。
PCF：percentage-closer filtering，这是一种多个不同过滤方式的组合，它产生柔和阴影，使它们出现更少的锯齿块和硬边。
正交：所有光线/视线都是平行的，用在定向光上
投影：经常用在点光源和聚光灯上，有自己的位置。
点光源阴影：（动态阴影）过去的名字是万向阴影贴图技术。
定向阴影映射和万向阴影映射的主要不同在于深度贴图的使用上。

法线贴图：
现实世界中的物体表面并非是平坦的，而是表现出无数细节。
我们可以用specular贴图根据深度或其他细节组织部分表面被照的更亮，以此来部分解决问题。
以光照视角来看，只有一件事决定物体的形态，那就是垂直于它的法线向量。每个fragment使用自己的法线，我们就可以让光照相信
一个表面由很多微小的平面组成，物体表面的细节将会得到极大提升。这种每个fragment使用各自的法线，替代一个面上所有fragment
使用同一个法线的技术叫做法线贴图或凹凸贴图。细节获得了极大提升，开销不大，因为只需要改变法线向量，并不需要改变光照公式。

切线空间：是位于三角形表面之上的空间。
切线空间的一大好处是我们可以为任何类型的表面计算出一个这样的矩阵，由此我们可以把切线空间的z方向和表面的法线方向对齐。
这种矩阵叫做TBN矩阵，这三个字母分别代表tangent，bitangent，normal向量

视差贴图：（我的理解是平面上的东西是不变的，但是观察者的位置发生了变化，从而产生了偏差）当表面的高度变化很快的时候，看起来不真实。
和法线贴图类似，能极大提升表面细节，使之具有深度感，利用了视错觉。属于位移技术帖图中的一种。
背后的思想就是修改纹理坐标使一个fragment的表面看起来比实际的更高或更低。
置换顶点有一个问题：平面必须由很多顶点组成才能获得具有真实感的效果，否则看起来效果并不会很好，一个平面由很多顶点计算量就太大了。
法线贴图通常根据高度贴图生成，法线贴图和高度贴图一起用能保证光照能和位移想匹配。
有些人更喜欢在等式中不使用viewDir.z，因为普通的视差贴图会在角上产生不想要的结果；这个技术叫做有偏移量限制的视差贴图。

陡峭视差映射：是视差映射的扩展，不是使用一个样本而是使用多个样本来确定向量P到B。
从上到下遍历深度层，把每个深度层和存储在深度贴图中的它的深度值进行对比，如果这层深度值小于深度贴图的值，意味着这一层的
P向量部分在表面之下。

视差遮蔽映射：
和陡峭视差映射的原则相同，但不是用触碰的第一个深度层的纹理坐标，而是在触碰之前和之后，在深度层之间进行线性插值。

HDR：默认亮度和颜色的值是被限制在0.0和1.0之间的，但是当我们遇上了一个特定的区域，多个亮光源使这些数值总和超过1.0，
超过1.0的颜色和亮度会被限制在1.0，从而导致场景混成一片，难以分辨。
办法：1.减小光源的亮度保证没有一个片段超过1.0，但是并不是一个好的方案。2.让颜色暂时超过1.0，然后将其转换到0.0到1.0的区间内，从而防止损失细节。
显示器被限制只能在0.0和1.0之间，但是光照方程没有这个限制，通过使片段的颜色超过1.0，有了更大的颜色范围，被称为HDR（高动态范围）
有了HDR，亮的东西可以非常亮，暗的东西可以变得非常暗，而且充满细节。
转换HDR到LDR值的过程叫做色调映射。现在有很多的色调映射算法，致力于在转换过程中保留尽可能多的HDR细节，这些色调映射算法
经常会包含一个选择性倾向黑暗或明亮区域的参数。

浮点帧缓冲：当一个帧缓冲的颜色缓冲的内部格式被设定成了GL_RGB16F, GL_RGBA16F, GL_RGB32F 或者GL_RGBA32F时，
这些帧缓冲被叫做浮点帧缓冲，浮点帧缓冲可以存储超过0.0到1.0范围的浮点值，所以非常适合HDR渲染。
默认的帧缓冲一个颜色分量只占用8位。

色调平衡：色调映射是一个损失很小的转换浮点颜色值至我们所需的LDR[0.0, 1.0]范围内的过程，通常会伴有特定的风格的色平衡。
HDR渲染的优点。通过改变曝光等级，我们可以看见场景的很多细节，而这些细节可能在LDR渲染中都被丢失了。

泛光：例如有一张在阳光下的白纸，白纸在监视器上显示出是出白色，而前方的太阳也是纯白色的，所以基本上白纸和太阳就是一样的了，给太阳加一个光晕，这样太阳看起来似乎就比白纸更亮了
光晕效果可以使用一个后处理特效泛光来实现。泛光使所有明亮区域产生光晕效果。
泛光本身并不是个复杂的技术，但很难获得正确的效果。它的品质很大程度上取决于所用的模糊过滤器的质量和类型。简单的改改模糊过滤器就会极大的改变泛光效果的品质。
高斯模糊：基于高斯曲线（钟形曲线）
每次循环我们根据我们打算渲染的是水平还是垂直来绑定两个缓冲其中之一，而将另一个绑定为纹理进行模糊。
第一次迭代，因为两个颜色缓冲都是空的所以我们随意绑定一个去进行模糊处理。
重复这个步骤10次，亮区图像就进行一个重复5次的高斯模糊了。这样我们可以对任意图像进行任意次模糊处理；
高斯模糊循环次数越多，模糊的强度越大。
通过对提取亮区纹理进行5次模糊，我们就得到了一个正确的模糊的场景亮区图像。
泛光的最后一步是把模糊处理的图像和场景原来的HDR纹理进行结合。
要注意的是我们要在应用色调映射之前添加泛光效果。这样添加的亮区的泛光，也会柔和转换为LDR，光照效果相对会更好。

延迟着色法（延迟渲染）：延迟或推迟大部分计算量非常大的渲染（例如光照）到后期进行处理。
包含两个处理阶段：1.先渲染场景一次，之后获取对象的各种几何信息，存储再一系列叫做G缓冲的纹理中。
我们一直使用的光照方式叫做正向渲染或者正向着色法，很容易实现，但是对程序性能影响也大。
保证G缓冲中的片段和在屏幕上呈现的像素所包含的片段信息是一样的

Gbuffer是对所有用来存储光照相关的数据，并在最后的光照处理阶段中使用的所有纹理的总称。
我们可以再次使用多渲染目标来在一个渲染处理之内渲染多个颜色缓冲
延迟着色法的一个缺点：不能进行混合，所有的数据都是从一个单独的片段中来的，混合需要多个片段的组合进行操作，迫使你对大部分
场景的光照使用相同的光照算法。
为了克服缺点（尤其混合）：通常分割渲染器为两个部分，1.延迟渲染的部分2.专门为了混合或者其他不适合延迟渲染管线的着色器效果而设计的正向渲染部分。
延迟渲染一直被称赞的原因就是因为它能渲染大量的光源而不消耗大量的性能，延迟渲染本身并不支持非常大量的光源，我们仍然要对每一个光源计算每一个片段的光照分量。
真正让大量光源成为可能的是我们对延迟渲染管线引用的一个非常棒的优化：光体积。
渲染光体积确实会带来沉重的性能负担，虽然它通常比普通的延迟渲染更快，这仍然不是最好的优化。
另外两个基于延迟渲染的更流行(并且更高效)的拓展叫做延迟光照和切片式延迟着色法
仅仅是延迟着色法它本身(没有光体积)已经是一个很大的优化了，每个像素仅仅运行一个单独的片段着色器，
然而对于正向渲染，我们通常会对一个像素运行多次片段着色器。
当然，延迟渲染确实带来一些缺点：大内存开销，没有MSAA和混合

环境光照，是我们加入场景总体光照的一个固定光照常量，被用来模拟光的散射。
一种间接光照的模拟叫做环境光遮蔽（AO），原理是通过将褶皱，孔洞和非常靠近的墙面变暗的方法近似模拟出间接光照。
SSAO屏幕空间环境光遮蔽，这一技术使用了屏幕空间场景的深度而不是真实的几何体数据来确定遮蔽量。
原理是对于铺屏四边形上的每一个片段，根据周边深度值计算一个遮蔽因子，之后会被用来减少或者抵消片段的环境光照分量。
遮蔽因子通过采集片段周围球型核心的多个深度样本，并和当前片段深度值对比得到的，高于片段深度值的样本的个数就是我们要的遮蔽因子。
通过在法向半球体周围采样，我们不会考虑到片段底部的几何体，消除了环境光遮蔽灰蒙蒙的感觉，产生了更真实的结果。
