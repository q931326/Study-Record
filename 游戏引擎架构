游戏引擎架构（第2版）：
第一部分(基础)：
第一章：
问题：1.如何架构工业级生产用游戏引擎 	2.现实中的游戏开发团队怎样组织及运作。
3.有哪些主要子系统及其设计模式不断出现在游戏引擎中，每个主要子系统的典型需求。
4.有哪些子系统与游戏类型或具体游戏无关，有哪些子系统是为某游戏类型或具体游戏类型设计的
5.引擎和游戏的边界位于何处。

游戏工作室由5个基本专业领域的人员构成，包括工程师，艺术家，设计师，制作人，其他管理/支持人员。

工程师分为两类：运行时程序员（制作引擎和游戏本身），工具程序员（制作离线工具，供整个团队使用）
资深工程师有时候会被赋予技术领导的角色，通常仍会设计及编写代码，同时协助管理团队的时间表，决定项目的整体技术方向。
有些公司设有一位或多为技术总监（TD）负责从较高层面监督一个或多个项目，确保团队能注意到潜在的技术难点，业界走势，新技术。
某些工作室可能还有一个和工程相关的最高职位——首席技术官（CTO），类似整个工作室的技术总监。

艺术家分为：
概念艺术家（通过素描或绘画让团队了解游戏的预设最终面貌），
三维建模师（前景（制作物体，角色，载具....）/背景建模师（制作静态的背景几何模型（地形，建筑物，桥梁）））
纹理艺术家（制作纹理的二维影像），灯光师（布置游戏世界的静态或动态光源）
动画师（为游戏中 的角色及物体加入动作）动画捕捉演员（提供一些原始的动作数据）
音效设计师（与工程师紧密合作，制作并混合游戏中的音效及音乐）配音演员，作曲家
同工程师，资深艺术家有时候会称为团队领导，一些游戏有一位或多位艺术总监，把控游戏艺术风格，维持作品的一致性。

游戏设计师：
负责设计玩家体验的互动部分，一般叫做游戏性，有时候会聘请一位或多位作家。

制作人及其他工作人员（包括行政管理团队，市场策划团队，行政人员/IT部门）

游戏是什么：大部分二维或三维游戏，会被计算机科学家称为 软实时 互动 
基于代理（模拟多个独立的实体一起互动，例如游戏中的载具，人物角色，火球.....） 计算机模拟
所有互动的电子游戏都是以时间性模拟，即游戏世界是动态的，游戏必须回应玩家的输入，这些输入不可知，因此游戏是互动时间性模拟
最后，多数游戏会描述游戏的故事，并实时回应玩家的输入，使得游戏成为互动实时模拟。
时限是所有实时模拟的核心概念，明显的例子就是屏幕每秒最少更新24次，以制造运动的错觉。
”软“实时系统是指一些系统，即使错过期限却不会造成灾难性的后果（举例：如果帧数不足，人类玩家不会因此死亡），硬实时系统相反
模拟虚拟世界许多时候要用到数学模型：可分为解析式和数值式。

数据驱动架构：可以用来分辨一个软件哪些部分是引擎，哪些是游戏。
FPS游戏是开发难度极高的游戏类型之一：能于此相比的只有第三人称射击/动作/平台游戏，以及大型多人在线游戏。
注重技术：1.高效的渲染大型三维虚拟世界。2.快速反应的摄像机控制及瞄准机制。3.玩家的虚拟手臂和武器的逼真动画
4.各式各样的手持武器 5.宽容的玩家角色运动及碰撞模型 6.非玩家角色有逼真的动画及智能  7.小规模多人在线游戏的能力。

运行时引擎架构：
游戏引擎也是以软件层构建的，通常上层依赖下层，下层不依赖于上层，当下层依赖于上层时，称为循环依赖。任何时候都要避免循环
依赖，不然会导致系统间复杂的耦合。
硬件，操作系统，第三方软件开发包层（游戏也依赖数据结构（例如STL，STLport，Boost，Loki）图形OpenGL等，碰撞和物理，
角色动画，人工智能，生物力学角色模型，平台独立层），核心系统（断言（一种检查错误的代码），内存管理，数学库，自定义数据结构））
资源管理，渲染引擎（通常采用分层架构）（低阶渲染器，包含引擎中全部原始的渲染功能，
场景图/剔除优化（比较小的游戏平截头剔除算法）（比较大的游戏，较高阶的空间细分，
有多种形式包括二元空间分割树，四叉树，八叉树，kd树，包围球树），空间分割有时称为场景图），
视觉效果（粒子系统，贴花系统，光照贴图/环境贴图，动态阴影，全屏后期处理效果，HDR/bloom，FSAA全屏抗锯齿，颜色矫正/偏移）
前端：平视显示器HUD，图形用户界面GUI，全动视频FMV，游戏内置电影IGG（以三维形式渲染电影情节）
剖析和调试工具：内存资源容易短缺，开发者也要大量使用内存分析工具，调试功能包括试用绘图，游戏内置菜单，主控台，以及能够录制及回访游戏过程的功能，方便调试和测试。
碰撞和检测，动画（基本5种动画，精灵/纹理动画，刚体层次结构动画，骨骼动画，每顶点动画，变形目标动画）。
骨骼网络渲染组件是连接渲染器和动画系统的桥梁，动画系统生成骨骼种所有骨头的的姿势，
之后渲染器利用矩阵表去转换顶点，每个顶点用一个或多个矩阵生成最终混合顶点位置，此过程叫蒙皮。
人体学接口设备：键盘和鼠标，游戏手柄，其他专用游戏控制器。音频，
在线多人/网络，多人游戏最少有四种形式（单屏多人，切割屏多人，网络多人，大型多人在线游戏）
游戏性基础系统：游戏性是指：游戏内进行的活动，支配游戏虚拟世界的规则，玩家角色的能力，其他角色和对象的能力，玩家的长短期目标
游戏性基础层，游戏对象模型，软件对象模型。
事件系统，脚本系统，人工智能基础AI，个别游戏专用子系统。
工具及资产管道：游戏引擎需要读取大量数据：游戏资产，配置文件，脚本。所有源数据都由美术人员使用数字内容创作DCC。
DCC应用软件所使用的数据格式，很少适合游戏，原因有：1.DCC在内存种的数据模型，通常比游戏复杂的多，2.游戏中读取DCC格式文件速度过慢。
从DCC到游戏引擎的管道，有时候称为资产调节管道。	游戏中常见的几何图形：笔刷几何图形，三维模型/网格数据
骨骼动画数据：骨骼网格是一种特殊网格，有时候又称为皮肤。游戏引擎需要3种数据去渲染骨骼网络，1.网络本身2.骨骼层次架构3.动画片段
音频数据，粒子系统数据，游戏世界数据及世界编辑器。

第二章：
版本控制：
版本控制系统有如下功能：提供中央版本库，保留每个源文件的所有更改记录，提供为某些版本加上标签的机制，
供以后提取已加标签的版本，容许代码从主生产线上建立分支。
常见的版本控制系统：SCCS，RCS，CVS（并发版本管理系统），Subversion（简称SVN），Git（开源版本控制系统），Perforce，NxN，ClearCase，Visual SourceSafe
对象文件的机器码是：可重定位的，未链接的，项目（源文件的集合）及解决方案（负责容纳和管理项目的集合）
生成配置：是解决方案内个别项目的预处理器，编译器和链接器的选项集合。
多数项目的都至少两个生成配置（调试和发布），调试比发布生成运行的慢，但向程序员提供了宝贵的开发及调试信息。
预处理器设置：C++预处理器有一个极强大的功能，通过命令行定义预处理宏，和在代码中编写#define指令等效
编译器设置，是否包含调试信息，也可以控制编译器是否展开内联函数
链接器设置，例如控制输出文件的类型（可执行文件，DLL）指定链接哪些外部库至可执行文件，以及指定搜索哪些程序库的路径
链接器选项也可以控制堆栈大小，程序载入内存时的首选基址，代码在何平台上执行，以及许多其他细节选项。
典型生成配置：调试（关上各种优化，禁用所有函数内联，包含完整的调试信息），发布（仍然保留调试信息并开启断言），
制作（关上所有断言，完全启动优化），工具（有些工作室的工具和游戏本身共用代码库，加入工具配置很合理）
混合生成版本，指其配置中，大部分翻译单元是发布模式，只有一小部分翻译单元为调试模式，使用这种，容易调试当前要监察的代码，
而其余代码继续全速运行。
生成配置和可测试性：项目支持的生成配置越多，也就越难以测试。
项目支持的生成配置越多，就越难测试。
项目配置教程：最常用的4个种类是常规，调试，C/C++和链接器
根据经验，最好选择“所有配置”去编辑大部分的生成配置，这么做不需要为每个配置重复编辑，避免在某个配置中意外犯错。
常规属性：输出目录（决定生成的最终产品放于哪个目录之下，编译器/链接器最终输出可执行文件，库和DLL）
中间目录（定义中间文件在生成时输出的目录，主要为对象文件.obj扩展名，中间文件不需要包含在最终程序发行版里，只是在生成可执行文件，库，DLL过程时所需）
VS提供宏功能，能用来在项目属性页中设置目录或其他属性，本质是命名变量，变量的值按项目配置而全局设置的。
相对于手工硬性指定属性值，使用宏的好处是，修改宏的全局值会自动影响所有使用该宏的设置。
调试属性页，可指定要调试的可执行文件的名称及所在位置，也可指定命令行参数，在运行时传递至程序。
C/C++属性页：控制编译期的语言设置，影响代码如何从源文件编译至对象文件。并不影响对象文件最终链接至可执行文件或DLL。
一些常用的设置，
常规/附加的包含目录（此属性列举当读取#include头文件时所搜寻的目录，最好使用相对路径及/或VS提供的宏去设置这些目录,即使把生成目录移到磁盘上的其他位置或其他计算机，编译仍然可以照常运作）
常规/调试信息格式（此属性控制是否产生信息格式，举例调试及发布配置都包含调试信息，方便在开发游戏时追查问题，制作全部删除，防止程序被他人修改）
预处理器/预处理器定义（此属性可方便地列出任意数量的C/C++预处理符号，当编译源文件时候这些符号会被定义）
链接器属性页：
常规/输出文件（设置生成最终产品的文件名及所在目录）
常规/附加库目录（如同C/C++属性页的附加包含目录属性，当链接时要读取库或对象文件，就会搜寻此属性列出的目录）
输入/附加依赖项（此属性列出需要和可执行文件或DLL链接的外部库）

创建新的.vcproj文件
两种简单方法：
复制现有项目（先复制.vcproj文件，并在必要的时候修改该文件副本，在解决方案管理器右击解决方案，然后再弹出菜单中选择“Add->Existing Project...”即可加入复制出来的新项目）
在复制的时候注意，老项目的名称储存在.vcproj文件里，因此，当第一次加载该新项目到VS中，新项目仍然保留原来名称，为纠正问题
可在解决方案资源管理器中选择该项目，再按F2键为新项目起一个合适的名字。
需要注意，项目创建的可执行文件，库或DLL文件名是明确地在.vcproj里指定的，将.vcproj文件改为.xml扩展名，就可用VS打开。
另一漂亮的方法是用VS的宏系统，去指定项目中所有输出文件。

调试代码：
启动项目：
VS解决方案中可含有多个项目，一些项目会生成可执行文件，其余的生成库或DLL，在一个解决方案中可能含有多个生成可执行文件的项目
然后，某一个不能调试多余一个程序，因此，VS提供一个名为“Start-Up Project”的设定，调试器把启动项目视为当前要调试的项目。
断点：在VS中可选择某行代码用F9切换断点，当程序运行到含断点的代码时，调试器会停止程序，此为断点被命中。
单步执行代码：当断点被命中后可按F10单步执行代码，黄色程序计数器会移动，显示程序执行的代码行，F11能逐语句进入函数调用
F10逐过程而不进入函数调用
调用堆栈：
在主菜单选择Debug->Windows->Call Stack以显示调用堆栈窗口。命中断点时（或手动把程序暂停），双击调用堆栈窗口的条目
就可以调用堆栈里上下移动，此操作非常有用，能检查从main（）开始调用至目前代码行的一连串函数调用，例如，有时候在深入的嵌套
函数调用中，此方法能往上追查父代函数，从而找出bug源头。16:57 2023/11/1716:57 2023/11/17

监视窗口：在单步执行代码并在调用堆栈里上下移动时，程序员需要检查程序中变量的值，监视窗口就是为此而设的。要打开监视窗口，
可于主菜单栏中选择“Debug->Windows->watch(调试->窗口->监视)”，最后选择监视1至监视4。
监视窗口开启以后，可在窗口键入变量的名字，或从源代码直接拖动表达式至窗口。
监视窗口除了可显示变量的值，还可以调用程序中的函数，VS会自动重新为监视窗口内的表达式取值，因此，在监视窗口
内输入含函数的表达式，每次命中断点或单步执行代码都会调用那些函数。
在监视窗口中展开特大型数据结构时请务必小心，这么做有时候会使调试器速度变慢，甚至严重到不能使用的地步。
数据断点，常规的断点触发条件是CPU的程序计数器命中某个机器指令或代码行。然后现在的调试器提供另一个极有用的功能
就是设立另一种断点，其触发条件是数据写入（即改变）某指定地址，所以这种断点称为数据断点。
在VS中设置数据断点，有以下几个步骤：1.“Debug->Windows->Breakpoints”打开“断点”窗口
2.在窗口左上角按“New”3.选择新建数据断点（New Data Breakpoint） 4.键入原始地址或结果为地址的表达式
条件断点，任何种类的断点都可以设置条件和命中次数。
调试已优化的生成，以下是一些窍门，学习在调试器中阅读及单步执行反汇编，运用寄存器去推理变量的值或地址，
使用地址去检查变量及对象内容，利用静态和全局变量。
剖析工具：帕累托法则（在很多情况下一些事80%的后果取决于20%的原因），计算机科学常使用此法则的变种，称为90-10法则
指任何程序的90%挂钟时间消耗在运行仅10%的代码上。如何得知需优化的10%代码在哪里，用剖析器，剖析器能度量代码的执行时间
并告诉每个函数所花的时间，这些数据引导程序员去优化占“狮子份额”执行时间的函数。
一些剖析器也能告之每个函数的调用次数，函数耗用大量时间的原因（1.函数本身运行花费很长时间，2.函数被频繁调用）
若使用适当的剖析器，则能进一步获取更多信息，一些剖析工具能报告调用图，可告知某函数被哪些函数调用，
以及该函数调用了哪些函数，甚至可以知道函数的运行时间花在后代的百分比，以及每个函数占整体运行时间的百分比。
剖析器可分为两类：1.统计式剖析器（不唐突的，启动剖析器后，目标代码和没启动剖析器时间差不多）（原理：周期性地位CPU的程序计数器寄存器采样，并以此获得正在执行的函数）。
2.测控式剖析器：能提供最精确，最详尽的计时数据，但是却要以不能实时运行程序位代价，启动剖析器后，目标程序慢如蜗牛。
内存泄漏和损坏检测：原因都是因为指针
其他工具：区别工具，三路合并工具，十六进制编辑器
第三章：
封装继承（多重继承会有菱形问题，用虚函数解决）多态，合成及聚合
设计模式（最常用的有：单例，迭代器，抽象工厂）
编码标准：接口为王（保持.h文件整洁，简单，极小，易于理解），好名字促进理解及避免混淆，不要给命名空间添乱
遵从最好的C++实践，始终如一，显露错误。
数值表达形式：数值底数（几进制），有符号及无符号整数，定点记法，浮点记法（1位符号位，8位指数，23位尾数）
范围和精度的取舍，32位，由于浮点数表示不准确，1+e！=1，e称为机器的epsilon，e=2-23=1.192*10-7，因此1加上
任何小于e的值并无效果，有限精度和机器的概念对游戏软件有实质影响，假如用浮点数表示游戏从开始至今经过了时间称为
游戏绝对时间，游戏运行大约12.9日时候，再加上1/30秒，游戏时长维持不变。
char8位，int32位，short16位，double64位，long根据平台32/64位，float32位，bool8或32位
VS的C/C++编译器定义了以下的扩展关键字去声明特定位数的变量，__int8,__int16,__int32,__int64.
SIMD类型，算术逻辑单元（ALU）称为矢量处理器或矢量单元，矢量处理器提供一种并行处理方式，名为单指令多数据（SIMD）
单个SIMD指令可以并行地对多个数据进行计算，数据由矢量处理器处理，需要先把数据以两个或更多个数值打包，存进64位或128位CPU寄存器
游戏编程中，最常用的SIMD寄存器格式是4个32位IEEE-754浮点数值打包，存进128位SIMD寄存器，使矢量点乘和矩阵乘数更高效
每个微处理器的SIMD指令集名字各有不同，而且编译器对不同目标微处理器有特定的SIMD变量声明语法，例如奔腾系列CPU的
指令集称为单指令多数据流扩展SSE
可移植的特定大小类型：F32为32位IEEE-754浮点数，U8，I8，U16，U32，I32，U64，I64为无符号和带符号整数，依次代表8，16，32，64位整数
U32F，I32F为“高速”无符号和带符号32位整数，用作保存32位值，但实质上在内存占据了64位空间，
目的是让PS3的中央处理器能直接读/写这些变量到64位寄存器，比32位速度显著提升。
VF32代表把4个float的SIMD值打包。
OGRE，图像处理器（GPU）总是使用32位或16位浮点运算，GPU/FPU使用单精度浮点运算一般也比较快，多数游戏倾向于单精度浮点运算
多字节值及字节序：大于8位的值称为多字节量。
内存中储存多字节整数有两种方式：小端（最低有效字节于较低的内存位置）大端（最高有效字节位于较低的内存位置）
多数程序员不需要考虑字节序，然而字节序对程序员可能是一根刺，因为游戏通常是在英特尔CPU（小端）的PC上开发，游戏可能执行于
游戏主机，如Xbox，PS（可能是大端）等，此时就会出现问题，解决办法：1.所有数据以文字方式写入文件（每数字一个字节写入，会浪费磁盘空间，但可行），
2.工具先转换数据字节序，然后把转换后的数据写入二进制文件。
整数字节序转换（将最高有效字节和最低有效字节交换，再继续交换直到该值的中间点，唯一难点是知道哪些字节序要转换）
不可以简单地把Example对象转换为字节数组，并盲目地用单一通用函数去转换那些字节。必须知道那些数据成员要转换及每个成员的大小，并逐个成员分别进行转换。
浮点字节序转换，1.C++的reinterpret_cast操作去把浮点数诠释为整数，这又称为类型双关，当使用严格别名时，可能导致优化bug
2.取而代之，一个简便的方法是使用union
声明，定义及链接规范
C/C++程序是由翻译单元组成的，编译器每次都是翻译一个.cpp文件，并输出个别的对象文件（.o或.obj），编译器操作的最小翻译单元是.cpp文件
因此称为“翻译单元”，对象文件不仅含有.cpp文件内定义的所有函数编译后的机器码，也包含.cpp文件内定义的全局变量和静态变量
此外，对象文件也可能含有未解决引用，这些未解决引用是其他.cpp文件定义的函数和全局变量。编译器每次操作只针对一个翻译单元
遇到未解决引用的外部变量和函数，只能毫不怀疑地相信该变量或函数真的存在，链接器的任务就是把所有对象文件组合成最终可执行映像
链接器的功能是解决外部引用，因此只能报告两种错误：1.找不到extern引用的目标，报告“无法解决的外部符号”
2.找到两个及以上相同名字的实体，链接器报告“符号被多重定义”错误。
声明和定义：
声明：是数据对象或函数的描述，使编译器知道实体的名字，以及其数据类型或函数签名，即函数的返回值类型
定义：是程序中个别内存区域的描述，可能用来放置变量，struct，class实例，以及函数的机器码
声明是实体的引用，定义是实体本身，一个定义必然是一个声明。
多重声明和定义：可以有多个同等的声明，但只能有一个定义，若两个或更多同等定义位于一个翻译单元，编译器会报错，
但存在于不同的翻译单元，编译器发现不了错误，因为编译器每次是以翻译单位运作的
头文件中的定义，以及内联：
把定义置于头文件中，通常是危险的，若多个.cpp文件#include了含有定义的头文件，就肯定会产生“符号被多重定义”的链接错误
对此规则，内联函数是个例外，因为每个调用内联函数的地方都会复制该函数的机器码，把机器码直接嵌入调用方的函数里。
实际上，若内联函数要供多余一个的翻译文件使用，则该内联函数必须置于头文件中，编译器必须“看见”函数主体才能把函数内联
inline关键字只是给编译器的提示，编译器会为每个内联函数分析其内联的成本效益，即度量函数代码大小，决定是否对函数内联，编译器有最终决定权。
链接规范：外部链接（可被定义处以外的翻译单元看见并引用），内部链接（只能被该定义所处的翻译单元看见）
所有定义预设为外部链接，static把定义改为内部链接，从技术上说，声明不会有链接属性，不会在可执行映像中分配储存空间。
C/C++内存布局：
可执行映像：当生成C/C++程序时，链接器创建可执行文件，像UNIX的操作系统，包括许多游戏主机，都使用一种流行的可执行文件格式
称为可执行与可链接格式。可执行映像分为几个相连的块，称为段或节，映像文件最少由以下4个段组成：1.代码段（包含程序中全部函数的可执行机器码）
2.数据段（包含全部获初始化的全局及静态变量，链接器为这些变量分配所需内存，内存布局和程序执行时弯全一样，链接器会填入适当初始值）
3.BSS段，原意是由符号开始的块，包含程序中所有未初始化全局变量和静态变量，链接器只需简单地存储所需零值的字节个数
4.只读数据段，包含程序中定义的只读（常量）全局变量（指所有函数及类声明外的文件作用域，根据是否初始化，存于数据或BSS段），const类型

程序堆栈：当可执行程序被载入内存时，操作系统会保留一块称为程序堆栈的内存，当调用函数时，一块连续的内存就会被压入栈，
此内存块称为堆栈帧。
堆栈帧储存3类数据，1.储存调用函数的返回地址 2.保存相关CPU寄存器的内容 3.堆栈帧也包含函数里的所有局部变量或自动变量
当含自动变量的函数返回时，其堆栈帧就会被舍弃，该函数内的所有自动变量被视为不再存在。
全局和静态变量分配于可执行映像中，而局部变量则分配于程序堆栈之中。这两种储存方式都是静态的定义的，即所需内存大小布局在编译链接时就能知道
成员变量：class和struct的声明不占内存，仅是数据布局的描述

类的静态成员：1.用于文件作用域中，static意味着“限制变量或函数的可见性”，只有本.cpp文件才能使用该函数或该变量
2.当用于函数作用域中，static意味着“变量为全局，非自动，只在本函数内可见”
3.当用于struct或class中，意味着“该变量非一般成员变量，而是类似于全局变量”

对象的内存布局：
对齐和包裹（编译器通常会在布局中留下空隙，例如long和short类型大小不同，short后会空出，也可用#pragma pack设置不留空隙）
数据对齐是很重要的，现在许多处理器实际上只能正常地读/写已对齐的数据块，
如果不对齐，还需要掩码和位移操作取得32位整数的两部分，再用逻辑OR操作把两部分合并，把结果写入CPU的目标寄存器
一些微处理器甚至不做这些操作，这样读出来或写进去的就是随机数，有些微处理器，程序甚至崩溃
包含4个浮点数的SIMD矢量通常需要16字节对齐。在class或struct中，把较小的数据类型放置于较大类型中之间，编译器会加入填充
小成员组合在一起，包裹更高效。结构末端的填充保证了所有之后的数组元素皆是正确对齐的。
C++中类的布局：当B类继承A类，内存中B类的数据成员会紧接A类数据成员之后，每个新的派生类都会
简单地把其数据成员附加到末端，即使类之间可能因为对齐而加入填充。
当类含有或继承了一个或多个虚函数，就会在类的布局中添加了4字节（或目标硬件中指针需占的字节数目）
此4字节称为虚表指针，此4字节代表一个指针，指向名为虚函数表的数据结构，在每个类的虚函数表中，包含
该类声明或继承而来的所有虚函数指针。每个（含虚函数的）具体类都具有一个虚函数表，并且类的实例都会有虚表指针指向该虚函数表
虚函数表是多态的核心，促使我们在编写代码时无需考虑代码是和哪个具体类进行沟通的。

捕捉及错误处理：
错误类型：用户错误（指用户做了不正确的事情而引发的错误），程序员错误（代码本身的bug所导致的）
错误处理：处理用户错误应该越妥善越好，并向用户显示有用信息，然后容许用户继续工作——若处于游戏状态下则继续玩
程序员的错误不应采用“通知并继续”方针去处理，通常最好的处理方式是终止程序，并提供低阶调试信息，
促使程序员能快速鉴定及修正问题，理想情况下，在软件发布之前，所有程序员错误都会被捕捉及修正。
处理玩家错误：要以游戏性来处理错误，例如，玩家尝试位武器再装弹，而子弹用光了，可使用声音提示
及动画向玩家表明问题，而不强制退出游戏。
处理开发者错误：错误可能来自无效资产，有两种不同看法：1.避免坏游戏资产持续存在过久似乎很重要
从极端角度去看，处理坏游戏资产的办法就是当遇到任何一个游戏资产有问题时，
便不容许游戏执行，造成无效资产的始作俑者，便会有强大的动机去立即移除或修正该资产
2.游戏开发是混乱的迭代过程，实际上鲜有从一开始就产生“完美”资产的情况，游戏引擎应该尽可能健壮
最佳方式是找到这两个极端的平衡点，希望错误变得明显，并使团队可于问题存在的情况下继续工作。
若只因为某开发者尝试加入一个无效资产，就要团队所有成员暂停工作，这样代价实在太昂贵了，游戏工作室
向员工支付不菲的工资，当多个团队成员要暂停工作时，成本就会加倍增加，当然，我们应该在实际可行时才采用这种错误处理方式
银弹：用于比喻解决软件开发的根本性困难的有效手段
处理程序员错误：最佳方法是在源代码中嵌入错误检测代码，并且当检测到错误时中止程序，此机制名为断言系统
实现错误检测及处理：
1.返回错误码
2.异常 错误码返回也有短处：其中最大的问题大概是，检测到错误的函数与可处理错误的函数完全无关，
在最坏的情况下，调用函数堆栈里的第40个函数时，可能侦测到一个错误，而此错误必须由顶层游戏循环
或main（）函数处理逐一传送恰当的错误码至上一层，直至能处理错误的顶层函数
其中一个解决办法就是抛出异常，异常是C++的强大功能，它让检测到错误的函数，无须知道能处理该错误
的函数，就可将错误信息传到其余代码处。抛出异常时，程序员可选择把相关错误信息储存于某对象，其被称为异常对象
能把错误检测和错误处理分离，是个诱人的方式，在某些软件项目中也是极佳的选择，然而，异常会为程序
添加许多额外的开销，每个调用帧会变大，用来承载堆栈辗转开解时所需的额外信息，并且，堆栈的辗转
开解通常很慢，相比于简单返回函数，前者用时大约多一两倍，就算程序中仅有一个函数使用了异常，整个程序
都必须使用，编译器不能预知抛出异常时调用堆栈会有哪些函数。因此，游戏引擎中，有颇充分的理由去完全关掉异常处理
因为游戏主机的内存和效能都是有限的，游戏主机上的引擎大概永远不会使用异常，基于个人计算机而开发的游戏引擎，可以安然使用异常。
3.断言：是一行检查表达式的代码，当表达式求值为真，一切如常，但表达式求值为假，暂停程序，打印消息。
断言检查程序员的假设，就像是为bug而设的地雷，让程序员在最小影响下纠正问题，通过在代码中嵌入断言，
bug就会在其诞生之时对外宣布，那时最容易修正问题，因为程序员对代码的改动记忆犹新。
断言通常实现为一个宏，宏会在if/else子句里对表达式求值，若断言失败，就会调用函数，并使用一些汇编代码区暂停程序。
以下是一个典型的断言实现：
#if ASSERTIONS_ENABLED
//定义一个内联汇编让调试器暂停程序
//不同CPU的做法有所不同
	#define debugBreak() asm{ int 3; }
	#define ASSERT(expr)\
		if(expr){}\
	       	else\
		{
		reportAssertionFailure(#expr,__FILE__,__LINE___);\
		debugBreak();\
		}
#else
	#define ASSERT(expr) //不求值
#endif
外层的#if/#else/#endif用于剥除代码里的断言，若ASSERTION_ENABLED是非零值，ASSERT（）宏就被
定义为真正的版本，程序中所有断言检查就会生效，若断言被关上，ASSERT（expr）不做任何事情，
所有使用该宏的地方，实际上会被预处理器删除。debugBreak（）宏定义为一些汇编语言指令
这些指令会暂停程序，并把控制权转交调试器，这些指令因CPU而异，但通常是单个汇编指令。
ASSERT（）宏本身是用完整的if/else语句定义的，这个方式使ASSERT（）宏可以用在任何上下文中，
就算放进没有花括号的if/else中，也不成问题。
十分推荐在代码中使用断言，也必须注意断言的性能开销，可以考虑定义两种断言，惯常的ASSERT（）宏
在所有生成中保留，所以即使不在调试生成下也可以发现错误。第二种断言宏，可能命名为SLOW_ASSERT（）
只在调试生成中生效，显然SLOW_ASSERT()的效用较低，因为它们被排除于测试员每天玩的游戏版本之外
正确的使用断言极为重要，断言只应用于捕捉程序本身的bug，永远不要用来捕捉用户的错误。
另外，断言失败时，应该总是终止整个游戏程序，允许测试员，美术人员，设计师或其他非工程师跳过断言
这通常是个坏点子，换言之，断言应该只用来捕捉严重错误，若可以在断言后继续正常运行程序，最好采用
其他方式向用户报错。

				第4章：游戏所需的三维数学
游戏程序员最常使用的是三维矢量和矩阵
点和矢量：
点和笛卡尔坐标：点是n维空间里的一个位置，笛卡尔坐标系是游戏程序员最常用的坐标系，使用2个/3个互相垂直的
轴来描述二维或三维空间的位置，可以用2个/3个实数表示一个点P。
当然笛卡尔坐标系并非唯一选择，其他一些常用的坐标系如下：1.圆柱坐标系（3部分组成：垂直“高度”轴h，从垂直
轴发射出来的辐射轴r，和yaw角度θ），在圆柱坐标系中，以3个数字（Ph，Pr，Pθ）表示一个点P
2.球坐标系（也是3部分组成：分别是俯仰角（pitch）phi（Φ），偏航角（yaw），半径长度r）
虽然笛卡尔坐标系是游戏编程中最广泛使用的坐标系，但必须谨记，应为当前问题选择最合适的坐标系。
左手坐标系和右手坐标系的比较：
右手坐标系3个轴的方向（拇指指向x轴，食指指向y轴，中指指向z轴），左手坐标系用左手。
左右手坐标系相互转换十分容易，只需要把其中一个轴反转，并保留另外两个轴不变即可。
在一些应用中，使用某些约定比其他约定更好：例如，三维图形程序员一般以左手坐标系工作，并以y轴向上，x轴向右
，z轴向观察者离去。当三维图形以此坐标系渲染至二维屏幕时，z轴坐标增加意味着场景的深度增加（即与虚拟摄像机距离增加）。
矢量：指n维空间中包含模和方向的量，矢量可绘画成有向线段，线段自一点延伸至另一点。
矢量也可以用来表示点，只要把其尾固定在坐标系的原点，这些矢量有时候称为位置矢量或矢径。对我们来说，可以把
3个标量视为点或矢量，点是绝对的，矢量是相对的。
笛卡尔基矢量：为方便起见，通常会按笛卡尔坐标的3个主轴去定义3个正交单位矢量。沿x记作i，y为j，z为k。i，j，k
有时候称为笛卡尔基矢量。
矢量运算：方向+方向=方向，方向-方向=方向，点+方向=点，点-点= 方向，点+点无意义（不要这么做）
有一种针对点集的运算，叫闵可夫斯基和，它的定义中会对两个点（位置矢量）相加，可用于一些碰撞检测算法，也可
用于组合各形状的采样。
现在位置P1，速度是矢量v，可以找到下一帧位置P2，等式为P2=P1+（▲t）v（称为显示欧拉法）
判断两个球体是否相交，可以用两球体中心点：C1和C2，d=C2-C1，若d小于两球体半径之和，表示相交，否则不相交
计算平方根在多数计算机上都费时，如果可以，尽量改用模的平方。
归一化和单位矢量：单位矢量是模为1的矢量，单位矢量在三维数学和游戏编程中十分有用。
法矢量指矢量垂直于该表面，法矢量在游戏和计算机图形学中非常有用，例如一个表面可用一点和一个法矢量来定义，
在三维图形中，经常大量使用法矢量计算光线和材质表面之间的夹角。法矢量一般为单位矢量，但此非必须条件
点积和投影：点积又称为标量积，或内积。叉积，又称为矢量积或外积。
点积符合交换律，以及加法上符合分配律。
矢量投影：计算投影长度。
点积判定：共线：（a·b）=|a||b|=ab，共线但相反方向（a·b）=-ab，垂直（a·b）=0，相同方向大于0，相反小于0
其他点积的应用：例如可以判断敌人是在玩家前面还是后面，先用减法找出玩家位置至敌人位置，再乘以玩家面向的方向
叉积：a*b=[(aybz-azby),(azbx-axbz),(axby-aybx)]=(aybz-azby)i + (azbx-axbz)j + (axby-aybx)k
两个矢量的叉积会产生另一个矢量，该矢量垂直于原来的两个相乘矢量。
叉积的模|a*b|=|a||b|sinθ，叉乘的方向如果使用右手坐标系则用右手法则，反之。
利用手和数学计算并无关系，指挥影响数字在三维空间中的视觉化。叉积不符合交换律，符合反交换律需要添加负号。
叉积在加法上符合分配律，和标量乘法可做结合律，笛卡尔基矢量有以下叉积关系，i*j=k，j*k=i，k*i=j。
叉积可以用来求三角形表面或其他平面的法向量，例如平面上三点（p1，p2，p3）n=[(P2-P1)*(P3-P1)]
叉积也可应用在物理模拟中，当向一物体施加力，当且仅当施力方向离开中心点时，该力会对物体旋转产生影响。
由此产生的旋转力称为力矩，给定力F，从质心至施力点的矢量r，产生的力矩N=r*F。

矩阵：3*3矩阵中所有行及列矢量为单位矢量，则该矩阵称为特殊正交矩阵，各向同性矩阵，或标准正交矩阵。
矩阵乘法不符合交换律，矩阵乘法有时称为串接。
逆矩阵（乘以原矩阵等于单位矩阵），转置矩阵，标准正交矩阵的逆矩阵和转置矩阵是一样的，此特性非常好，因为计算
转置矩阵比计算一般逆矩阵要快得多
4*3矩阵：4*4仿射矩阵的最右侧必然是一列【0 0 0 1】T的矢量，因此，可以略去第四列，以节省内存。
在物理学中，一组坐标系代表一个参考系，有时候会称一组轴为坐标系，或简称frame，游戏业界会使用坐标空间一词（或简称空间）来表示一组坐标轴
模型空间：也可称为物体空间或局部空间。
世界空间：是一个固定坐标空间，游戏世界内所有物体的位置，定向和缩放都会用此空间来表示。
观察空间：又称为摄像机空间，是固定于摄像机的坐标系，观察空间原点置于摄像机的焦点。
基的变更：经常把物体的位置，定向和缩放从某个坐标系转换到另一个坐标系中，我们称此运算为基的变更。
内存中存储矩阵：1.把矢量（ic，jc，kc，tc）连续置于内存中，2.把矢量在内存中分散对齐（每列含一个矢量）。
方法1的好处，要取得4个矢量中的一个，只需要简单地索引矩阵，再把该位置4个连续数值当作包含4个元素的矢量。
此内存布局也有和行矢量等式匹配的好处之一。
方法2的好处，在含矢量运算功能的微处理器中进行快速矢量矩阵乘法。
大多数游戏引擎都会使用方法1，即用C/C++二维数组中的每行去存储矢量。
例如：float M[4][4];
	M[0][0]=ix;M[0][1]=iy;M[0][2]=iz;M[0][3]=0.0f;
	M[1][0]=jx;M[1][1]=jy;M[1][2]=jz;M[1][3]=0.0f;
	M[2][0]=kx;M[2][1]=ky;M[2][2]=kz;M[2][3]=0.0f;
	M[3][0]=tx;M[3][1]=ty;M[3][2]=tz;M[3][3]=1.0f;
在调试器中，矩阵M的样式如下：
M[][]
       [0]
	[0] ix
	[1] iy
	[2] iz
	[3] 0.0000
       [1]
	[0] jx
	[1] jy
	[2] jz
	[3] 0.0000
       [2]
	[0] kx
	[1] ky
	[2] kz
	[3] 0.0000
       [3]
	[0] tx
	[1] ty
	[2] tz
	[3] 1.0000
要得知使用中的引擎采用了哪个布局，其中一个方法是，寻找4*4平移矩阵生成函数，之后查看源代码，找出t矢量的
元素是怎么存储的。若不能读取数学库中的源代码（可能性比较小），则可以用容易辨认的平移矢量，如（4，3，2）
去调用平移生成函数，再查看其传回的矩阵。若第三行含有4.0，3.0，2.0，1.0，是以行储存，否则以列储存。

四元数：1.矩阵需要9个浮点数表示旋转，显然有点冗余，因为旋转只有3个自由度（DOF）--偏航角，俯仰角，滚动角
2.用矢量矩阵乘法来旋转矢量，需要3个点积，即9个乘数及6个加数，若有可能，我们希望找到一种旋转表示方式，加快旋转运算。
3.在游戏和计算机图形学中，经常需要计算在两个已知旋转之间，某个比例的旋转。若以矩阵表示A和B的定向，要计算这些中间值很困难的
幸好有一个旋转表达形式能克服以上3个问题，称为四元数。遵守一组规则
（实数域上的四维赋范可除代数）单位长度的四元数（qx2+qy2+qz2+qw2=1的四元数）能代表三维旋转。
q=[qx qy qz qw] 	qx=qvx=axsinθ/2	qy=qvy=aysinθ/2	qz=qvz=azsinθ/2	qw=qvw=cosθ/2
四元数运算，四元数提供许多矢量代数中常见的运算，例如，模及矢量加法，必须谨记，两个四元数相加的和并不能代表
三维旋转，因为该四元数并不是单位长度的，因此，在游戏引擎中不会看见四元数的和，除非用某方法缩放至符合单位长度的要求。
四元数乘法：给定两个四元数p，q，pq代表两旋转的合成旋转（旋转q后旋转p），四元数乘法有几种，和三维旋转
应用有关的乘法称为格拉斯曼积，此定义下，pq之积为：pq=[(psqv+qspv+pv*qv)(psqs-pv*qv)]
共轭q*=[-qv qs]矢量部分求反，但保持标量部分不变。有了这个共轭定义，逆四元数q-1定义如下：q-1=q*/|q|2
由于我们使用的四元数都是代表三维旋转的，四元数都是单位长度，这种情况下，共轭和逆四元数相等。
球面线性插值：lerp运算的问题在于，它没考虑四元数其实是四维超球上的点，lerp实际上是沿超球的弦进行插值，
而不是在超球面上插值，导致旋转动画并非 恒定角速度进行，旋转在两端较慢，中间会快，解决此问题，采用
lerp运算的变体-----球面线性插值，简称SLERP，使用正弦和余弦在四维超球面的大圆进行插值，而不是沿弦上插值。
qlerp=lerp（qa，qb，β）=（1-β）qa+βqb/|（1-β）qa+βqb|    slerp（p，q，β）=wpp+wqq，
slerp和lerp公式相似，但其加权值以Wp和Wq取代（1-β）和β。
比较各种旋转表达方式：
欧拉角：由三个标量值组成：偏航角，俯仰角，滚动角。此表达方式优势在于既简单又小巧，还直观。但是会遭遇万向节死锁的状况
3*3矩阵：方便有效，不受万向节死锁问题，但是不太直观，看见一个大数字表，不容易把它们进行对应三维空间转换，不容易插值，需要大量存储空间（9个浮点数）
轴角（以单位矢量定义的旋转轴）：优点比较直观且紧凑，也可以来表示旋转，称为轴角表达方式，只需要4个浮点数。
不能简单地插值，不能直接施于点或矢量，须先把轴角换为矩阵或四元数。
四元数：1.能串接旋转，把旋转直接施于点和矢量，2.可轻易地用LERP或SLERP运算进行旋转插值。只需存4个浮点数。
SQT变换：单凭四元数只能表示旋转，4*4矩阵可表示任意仿射变换，当四元数结合平移矢量和缩放因子，就能得到4*4
仿射矩阵的可行替代形式，称为SQT变换。
对偶四元数：一个数学对象可完整表示涉及旋转，平移，缩放的变换

其他数学对象：直线，光线，线段。球体，平面（Ax+By+Cz+D=0）
轴对齐包围盒（AABB）：轴对齐包围盒是三维长方体，其6个面都与某坐标系的正交轴对齐，AABB可用六元素矢量
[xmin  xmax  ymin  ymax  zmin  zmax]表示，即3个主轴上的最大值和最小值，又或以Pmin，Pmax表示，因为AABB
的交集测试这么高效，常会用作碰撞检测“早期淘汰”测试，若两个AABB不相交，则不用做更详细的检测。
定向包围盒（OBB）三维长方体，但其定向与其包围的物体按照某逻辑方式对齐，通常OBB与物体的局部空间轴对齐
有多种方法测试一点是否在OBB之内：常见方法是把点变换至OBB的“对齐“坐标空间，再运用上节中的AABB相交测试
平截头体：由6个平面构成，定义截断头的四角锥形状，常见于三维渲染，因为透视投影由虚拟摄像机视点造成，所以
其三维世界中的可视范围是一个平截头体，平截头体上下左右代表平面四边，前后两面代表远近剪切平面。
测试一点是否再平截头体中有点复杂，基本上用点乘法去测出该点是在每个平面的前面还是后面，若该点皆在6平面以内，则该点再平截头体内
一个技巧就是把要测试的世界空间点，通过摄像机透视投影变换至另一空间，叫做齐次裁剪空间。平截头体在该空间变为AABB
凸多面体区域：由任意数量的平面集合定义，平面的法线全部向内。测试一点是否在平面构成的体积内，方法简单直接。

多媒体扩展MMX指令集，把多个8/16/32位整数载入特设的64位MMX寄存器，MMX指令集就能对那些寄存器进行SIMD运算
Intel陆续加入多个版本的扩展指令集，称为单指令多数据流扩展SSE。游戏引擎中最常用的SSE模式为32位浮点数打包模式
此模式中，4个32位float值被打包进单个128位寄存器中，单个指令可对4对浮点数进行并行运算，如加法或乘法
储存于SSE寄存器的4个浮点数，可以个别抽出存进内存，或从内存载入，但是操作速度相对较慢，简而言之，应该把普通的float运算和SIMD运算的混合代码视作瘟疫，避之不迭
为了把内存，x87FPU（浮点运算器）寄存器和SSE寄存器之间的数据传输量降到最低，多数SIMD数学库都会尽量把数据存在SSE寄存器中
而且越久越好，即使标量值也存在SSE中，可把单个浮点数复制至SSE寄存器的4个位置以表示标量，因此若要储存一个标量s至SSE寄存器，设x=y=z=w=s
VS提供了内建的__m128数据类型，可用来声明全局变量，自动变量，甚至是类或结构的成员变量，大多数情况，储存在内存中，
在计算时直接在CPU中的SSE寄存器中使用，而非内存中的程序堆栈。
当___m128变量储存在内存中，程序员有责任确保该变量是16字节对齐的，当编译器要动态分配数据结构，程序员须负责对齐
SSE内部函数编码，可用原始的汇编语言实现，也可用C/C++中的内联汇编，为了更方便，现今的编译器提供内部函数
.cpp文件需#include<xmmintrin.h>才能使用__m128数据类型和SSE内部函数
___declspec(align(16))强制声明16字节对齐，若省略，程序运行会崩溃
随机数在游戏引擎中无处不在，两个最常见的随机数产生器：线性同余产生器，梅森旋转算法。
线性同余产生器（LCG）：可以很简捷地产生伪随机序列，有些平台会使用此算法来实现标准C语言库的rand（）函数，然后，实际情况
在个平台可能有所不同，因此不要认为rand（）总会基于某一特定算法。LCG并不能产生特别高质量的伪随机序列，若给定相同的
初始种子值，则产生的序列会完全相同，LCG产生的序列并不符合一些广泛接受的准则，比如长周期，高低位有接近的长周期，
产生的值在序列上和空间上都无关联性。
梅森旋转算法（MT）伪随机产生器的算法是特别为改进LCG的众多问题而设计的，MT设计有庞大的周期，2的19937次方-1
在实际应用中，只在很少情况下需要更长周期，因为大部分应用都不需要2的19937个唯一组合（2的19937次方约等于4.3*10的6001次方）
MT有非常高阶的均匀分布维度，输出序列里的连续数字，其序列关联性微不足道，MT很快，MT通过了多个统计随机性的测试，包括严格的Dirhard测试

第二部分：低阶引擎系统
第5章：
游戏支持系统：
C++的静态初始化次序（是不可用的）在进入main之前全局及静态变量已被创建，然而，我们完全不可预知这些构造函数的
调用次序，在main结束返回之后，会调用全局及静态对象的析构函数，调用次序也无法预知，因此不合适。
按需建构：函数内声明的静态变量并不会于main（）之前建构，而是在第一次调用该函数时才建构，因此，若把
全局单例改为静态变量，我们就可以控制全局单例的建构次序。遗憾的是，此方法不可控制析构次序。仍然难以预计且危险
OGRE本质是渲染引擎而不是游戏引擎，但是也提供许多完整游戏引擎都有的底层功能。
内存管理：内存对性能影响有两方面：
1.以malloc（）或new运算符进行动态内存分配，是非常慢的操作，要提升性能，最佳方式是避免动态分配内存，
也可以利用自制的内存分配器来大大降低分配成本。
2.在现代的CPU上，软件的效能受其内存访问模式主宰。我们将看到，将数据置于细小连续的内存块，效率会高很多。
优化动态内存分配：堆分配通常是非常慢的，必须处理任何大小的分配请求，需要大量的管理开销，导致malloc和free
函数变得缓慢，其次在多数操作系统中，会从用户模式切换至内核模式，处理请求再切换回去，上下文切换会浪费很多时间。
因此游戏开发中一个常见的经验法则是：维持最低限度的堆分配，并且永不在紧凑循环中使用堆分配
当然，任何游戏引擎都无法完全避免动态内存分配，所以多数游戏引擎会实现一个或多个定制分配器
定制分配器比操作系统分配器更优的性能特征，原因有二：1.定制分配器从预分配的内存中完成分配请求（预分配的
内存来自malloc（），new或声明为全局变量），这样分配过程都在用户模式下进行，完全避免了上下文切换。
2.通过对定制分配器的使用模式做出多个假设，定制分配器便可以比通用的堆分配器高效的多。
基于堆栈的分配器：许多游戏以堆栈形式分配内存，载入游戏关卡时，为关卡分配内存，关卡载入后，很少甚至不会动态分配内存
玩家完成关卡时，关卡的数据就会被卸下，所以关卡占用的内存也可被释放。
堆栈分配器：要分配一大块连续内存，可简单使用malloc（），全局new，或是声明一个全局字节数组。
另外要安排一个指针指向堆栈的顶端，指针以下的内存是已分配的，指针以上的内存是未分配的。
使用堆栈分配器时，不能以任意次序释放内存，必须以分配时相反的次序释放。
回滚顶端指针的时候，回滚的位置必须位于两个分配而来的内存块之间的边界，否则，写入新分配的内存时，会重新
写进之前最高位置内存块的末端。为保证能正确地回滚指针，堆栈分配器通常提供一个函数，函数传回一个标记，代表
目前堆栈的顶端，而回滚函数使用这个标记作为参数。
双端堆栈分配器：一块内存其实可以给两个堆栈分配器使用，一个从内存块的底端向上分配，另一个从内存块的顶端向下分配
池分配器：预分配一大块内存，大小刚好是分配元素的倍数，池内每个元素会加到一个存放自由元素的链表。
在对池进行初始化时，自由列表包含所有元素，池分配器收到分配请求时，就会把自由链表的下一个元素取出，
并传回该元素，释放元素之时，简单地把元素插回自由链表中。储存自由元素的链表可实现为单链，即自由元素需要
储存一个指针，为取得储存这些指针的内存，我们可以再预分配一块内存储存这些指针，大小为指针数量*大小，但是
太浪费内存了，我们可以用自由列表内的内存块，只要元素尺寸>=sizeof（void*）就可以使用。若元素尺寸小于指针
可以使用池元素的索引代替以指针去实现链表，若池是用来存放16位整数的，便可在链表中用16位索引作为next指针
含对齐功能的分配器：每个变量和数据对象都有对齐要求，8位整数可对齐至任何地址，32位必须4字节对齐。
计算调整偏移量的方法：首先用掩码把原本内存块地址的最低有效位取出，再把期望的对齐减去此值，结果就是调整偏移量
当稍后要释放此内存块时，代码会传给分配器调整后的地址，而非原本我们分配的地址，那么怎么才能释放原本分配的
内存呢？我们要把调整后的地址转换为原来的，可能未对齐的地址。我们可以储存一些元信息至额外分配的内存，用来
做对齐之用。
单帧和双缓冲内存分配器：几乎所有游戏都会在游戏循环时分配一些临时用数据，这些数据要么在循环迭代结束时丢弃
要么在下一迭代结束时丢弃，这两种分配模式分别称为：单帧分配器和双缓冲分配器。
单帧分配器的主要益处是：分配了的内存永不用手动释放，依赖于每帧开始时分配器会自动清除所有内存，极其高效。
缺点在于：程序员必须有不错的自制能力，绝不能把指向单帧内存块的指针跨帧使用。
双缓冲分配器：实现方法，建立两个相同尺寸的单帧堆栈分配器。
内存碎片：会随时间产生内存碎片，当程序启动时，整个堆空间都是自由的。问题在于：就算有足够的自由内存，分配
请求仍然可能会失败，分配的内存必须是连续的，要满足一个128KB的分配请求，必须有一个自由的“洞”，尺寸大约为
128KB或更大，两个各64KB会失败。在支持虚拟内存的操作系统上，内存碎片并非大问题，虚拟内存系统把不连续的
物理内存块——每块称为内存页——映射到虚拟地址空间，使内存页对于应用程序来说，看上去是连续的。多数游戏引擎不会使用虚拟内存
以堆栈和池分配器避免内存碎片，堆栈分配器完全避免了内存碎片的产生，因为堆栈分配器分配到的内存块总是连续的
池分配器也无内存碎片问题，虽然会产生内存碎片，但是不会像一般的堆，提取引发内存不足的问题，因为所有池内存块完全一样大
碎片整理及重定位：若要分配及释放不同大小的对象，并以次序进行，那么堆栈和池分配器不适用。对付这种情况，
可以对堆定期进行碎片整理，碎片整理能把所有自由的“洞”合并，把内存从高位移至低位。把“洞”移至内存的高地址
但是若有指针指向这些内存块，移动内存会使这些指针失效。其中一个解决方案就是把指向这些内存块的指针逐一更新
使移动内存块后这些指针能指到新的地址，此过程称为指针重定位，遗憾的是C/C++没有方法可以搜寻所有指向某地址
范围的指针，若要在游戏引擎中支持碎片整理功能，必须小心手动维护所有指针，在重定位时正确更新指针，
另一个选择是，舍弃指针，取而代之，使用更容易重定位时修改的构件，例如智能指针或句柄（实现为索引）。
这些索引指向句柄表内的元素，每个元素储存指针，句柄表本身不能被重定位。当要移动某已分配内存块时，就可以扫
描该句柄表，并自动修改相应的指针，由于句柄只是句柄表的索引，无论如何移动内存块，句柄的值不变。因此，
使用句柄的对象永不会受内存重定位的影响。另一难题是，某些内存块不能被重定位，例如，若使用第三方库，而
该库不使用智能指针或句柄，那么指向库内数据结构的指针可能不能被重定位。要解决此问题，最好的方法是让这些库
在另一个特别缓冲区里分配内存，此缓冲区位于可重定位内存范围以外，另一方法是干脆容许一些内存块不能被重定位，
若这种内存块数量少，体积小，重定位系统仍可运行得相当好。
分摊碎片整理成本：因为碎片整理要复制内存块，所以操作过程可能很慢，然而，我们无须一次性把碎片完全整理，取而代之
我们可以把碎片整理成本分摊至多个帧，我们容许每帧进行多达N次内存块移动，N是个小数目，如8/16，这样堆通常能
在少于1s内完全整理所有碎片，而不会对游戏帧率产生明显影响，只要分配及释放的次数低于碎片整理的移动次数，
那么堆就会经常保持接近完全整理的状态，此方法只对细小的内存块有效，使移动内存块的时间短于每帧配给的重定位时间。
缓存一致性：
缓存是一种特殊的内存，CPU读写缓存速度比主内存快得多，内存缓存是，当首次读取某区域的主内存，该内存小块会
载入高速缓存，这个内存块单位称为缓存线，缓存线通常介乎8至512字节，若后来再读取内存，而该数据已在缓存中，
那么数据就可以直接从缓存载入寄存器，这比读取主内存要快得多，仅当要求的数据不在缓存中，才必须存取主内存，
这种情况叫缓存命中失败。每当出现缓存命中失败，程序便要暂停，等待缓存线自主内存更新后才能继续运行。
最简单的缓存写入设计称为透写式缓存，写入数据到缓存时，会立即把数据同时写入主内存，然而，在另一种回写式
的缓存设计中，数据会先写在缓存中，在某些情况下才会把缓存线回写到主内存，这些情况包括：一条曾写过新数据的
缓存线需要逐出缓存，以自主内存载入新的缓存线，程序明确要求清除缓存。
显而易见，我们无法完全避免缓存命中失败，因为数据始终要在缓存和主内存之间移动。高效计算的诀窍在于：以最优
的方式安排内存中的数据及为算法编码，尽量减少缓存命中失败的次数。
一级及二级缓存：在发展缓存技巧之初，缓存内存是置于主板上的，缓存由比主内存更快更贵的内存模板构成，从而
能达至提升速度之效。后来发展出更快的缓存内存种类，这种缓存直接置于CPU芯片上，产生了两种缓存，在CPU上的
一级缓存，在主板上的二级缓存。近来L2缓存也移至CPU芯片上了。L2缓存命中失败通常比L1缓存命中失败成本高，因为L2比L1慢
指令缓存和数据缓存:数据和代码都会置于缓存内，指令缓存会预载即将执行的机器码，而数据缓存用来加速自主内存读
写数据。大多数处理器会在物理上独立分开这两种缓存，因此，程序变慢，有可能因为指令缓存命中失败，或数据缓存
命中失败。
避免缓存命中失败：最佳方法是把数据编排进连续的内存块中，尺寸越小越好，并且要顺序访问这些数据，
这样便可以把数据缓存命中失败的次数减至最少。当数据是连续的，那么单次命中失败便会把尽可能多的相关数据载入
单个缓存线。
要避免指令缓存命中失败：基本原理和数据缓存的情况一样，由于编译器和链接器决定了代码的内存布局，读者可能会
觉得自己对指令缓存命中失效几乎无法控制，然后，多数C/C++链接器有一些简单的规则，知悉并运用它们就能控制
代码的内存布局，1.单个函数的机器码几乎总是置于连续的内存，绝大多数情况下，链接器不会把一个函数切开，在中间放置另外一个函数
2.编译器和链接器按函数在翻译单元源代码中的出现次序排列内存布局
3.因此，位于一个翻译单元的函数总是置于连续内存中，即链接器不会把已编译的翻译单元切开，中间加插其他翻译单元的代码
按照数据缓存命中失败的原理，我们可以使用以下的经验法则：
1.高效能代码体积越小越好，体积以机器码指令数目为单位，2.在性能关键的代码段落中，避免调用函数
3.若要调用某函数，就把该函数置于最接近调用函数的地方 4.审慎地使用内联函数，虽然能增进效能，但是增大代码体积
容器：数组，动态数组，链表，堆栈，队列，双端队列，优先队列，树，二叉查找树，二叉堆，字典，集合，图，有向非循环图
相比于直接访问容器的元素，采用迭代器的好处包括：1.直接访问会破坏容器类的封装，而迭代器通常是容器类的友元，
因此它可以高效迭代访问容器，同时不向外面暴露容器类的实现细节。2.迭代器简化了迭代过程。
前置递增和后置递增，建议选择前置递增，因为后置递增先备份旧值，再递增。在迭代器中导致效能损失（因为要进行复杂的迭代器对象构建及复制）。
建立自定义的容器类，游戏引擎设计师有以下几种选择：STL，STLport，Boost，
STL提供了丰富的功能，在不同平台上也有尚算健壮的实现，几乎所有C++编译器都带有STL
缺点：陡峭的学习曲线，占用更多内存，相比为某问题而打造的数据结构，STL通常会慢，STL会进行许多动态内存
分配工作，STL的实现和行为在各编译器上有微小差异，STL一般不适合主机游戏，适合PC上运行的游戏引擎
因为主机游戏内存受限制，缺乏高级CPU和虚拟内存
经验法则：1.使用STL类前，要认识其效能和内存特性，2.若认为代码中的重量级STL类会造成瓶颈，尝试避免使用它们。
3.占小量内存的情况下使用STL，4.若引擎需要支持多平台，推荐STLport，兼容多个编译器和目标平台设计的，比STL更高效，功能更丰富。
Boost：1.提供许多有用但STL没有的功能，2.在某些情况下，提供了替代方案，能解决一些STL设计上或实现上的问题
3.能有效地处理一些非常复杂的问题，例如智能指针。4.大部分Boost库的文档写得很好，不单解释每个库做什么和如何使用
，很多时候还会深入讨论开发该库的设计决定，约束及需求。
告诫：1.大部分Boost核心类都是模板，会生成大量.lib文件，可能不适合非常小型的游戏项目。
2.虽然Boost是极好的支援网络，但Boost库不提供任何担保，若读者碰到bug，你的团队有最终责任避开问题或修正bug
3.不保证支持向后兼容，4.按Boost软件许可证发布的，请小心阅读许可证内容。
Loki：C++有一门比较深奥的分支，叫做模板元编程，TMP的核心概念是利用编译器做一些通常在运行期才会做的工作
运用C++模板功能诱使编译器做一些原本并非为此而设的事情。最知名且可能是最强大的C++TMP库是Loki。
Loki两大缺点：1.代码可能望而生畏，难以使用及全面理解 2.有些元件依赖某些编译器的“副作用”行为，须细心调整
才能用在新的编译器上，移植能力较弱，不适合胆小者。
在游戏编程中，经常使用C风格的固定大小数组，因为这种数组无须内存分配，又因连续而对缓存友好。
当数组的大小不能在编译时决定时，程序员会倾向于链表或动态数组，若我们想维持固定大小数组的效能和特性，通常选动态数组。
链表：主要考虑因素并非内存的连续性而是希望在任何位置高效插入及移除元素，那么链表是首选
外露式表：是一种链表，其节点数据结构完全和元素的数据结构分离。一个元素能同时置于多个链表，只需为每个链表
分配独立的节点，指向该共享元素，缺点是，必须动态分配节点。许多时候，用池分配器分配节点。
侵入式表：是另一种链表，其节点的数据结构被嵌进目标元素本身，此方式的最大好处是无须再动态分配节点，每次分配元素时已免费获得节点
缺点：每个元素不能同时置于多个链表中，若要把元素同时加入N个链表，可在元素中加入N个节点成员。
若不惜一切代价都要避免动态内存分配，侵入式表是最佳的，若能负担得起池分配的开销，外露式表可能更合适。
单向链表：明显地能节省内存，其代价在于插入或移除元素，由于没有前指针，需要从头遍历才能找到前节点。
在散列表中，所有值储存于固定大小的表中，表中每个位置表示一个或多个键，要插入键值对时，首先要把键转换为
整数类型，此转换过程称为散列，然后把散列后的键模除表的大小得到索引，若无碰撞发生，用键查找散列表复杂度为O（1）。
碰撞：开放和闭合散列表
有时候两个或以上的键最终会占用散列表的同一位置，此情况称为碰撞，有两种基本方法解决碰撞。
1.开放式散列，碰撞发生时，多个键值对储存在同一位置上，这些键值对通常以链表形式储存，此方法容易实现，并且
储存于表中的键值对数目并无上限。然而，每次对这种散列表加入新键值对都要动态分配内存。
2.闭合式散列：在闲合式散列表中，解决碰撞的方法是进行探查，直至找出空位，方法比较难实现，必须要设定表的键值对
数目上限，但优点是所需内存是固定的，散列表建立后不用再分配动态内存。
散列法：把任意数据类型的键转换为整数的过程，该整数模除表的大小就能求得表的索引，数学上可以表示为，给定
键k，我们希望可以使用散列函数H，产生整数散列值h，然后求表的索引i，h=H（k），当中N是表的位置数目，mod
表示模除运算，求h整除N的余数。
在闭合散列表中，要解决碰撞问题，就要使用探查法，最简单的探查法是线性探查。线性探查往往使键值对聚集成群
要避免产生这些集群，可使用名为二次探查的算法。在使用闭合散列时，把散列表设为质数大小是个好主意。

字符串：字符串类含有隐性成本，在性能分析之前难以预料，例如传递字符串对象时，若函数的声明或使用不当，可能
引起一个或多个拷贝构造函数的开销， 复制字符串，可能涉及动态内存分配，这会导致一个看似无伤大雅的函数调用
最终可能花费几千个机器周期，因此，在游戏编程时一般会避免字符串类。
唯一标识符：字符串散列标识符：游戏程序员常用字符串标识符指这种散列字符串，虚幻引擎称为name
本地化：
Unicode：ASCII字符串对只有少量字母的语言没问题，但对于含大量字符的语言，其字形和英语的26个字母完全不同
ASCII无能为力了，Unicode应运而生。
UTF-8：每个字符占1-3字节，因此UTF-8字符串所占的字节数量不一定等于其长度，此称为多字节字符串。因为每个
字符占一至多个字符的储存空间。向后兼容ASCII编码，可以向后兼容，是因为多字节字符，其首字节最高有效位必然是1。
UTF16：采用更简单但较昂贵的方法进行编码，每个字符都确切地使用16位，字节/2就是字符的个数，是宽字符集。
Windows下的Unicode：wchar_t数据类型能用来表示单个“宽”UTF-16字符（WCS），char用作ANSI字符串及多字
节UTF-16（MBCS）字符串，Windows容许程序员编写字符串集无关的代码，为此Windows提供名位TCHAR的数据类型。
在云云Windows API中，前缀或后缀位‘w’wcs 或W表示宽（UTF-16）字符，前缀或后缀为t，tcs或T表示目前的
字符类型（可能是ANSI或UTF-16），无前缀后缀表示旧时普通ANSI，STL也使用相似的命名方式
Windows下，几乎所有涉及字符串的C标准库函数都有WCS和MBCS版本，遗憾的是API调用不使用UTF-8或UTF-16术语
而且函数的命名并非完全一致，这对不清楚底蕴的程序员可能造成混淆。
ANSI：strcmp(),strcpy(),strlen(),WCS：wcscmp(),wcscpy(),wcslen(),MBCS：_mbscmp(),_mbscpy(),_mbslen()
Windows也提供函数对ANSI，多字节UTF-8，UTF-16字符串之间进行转换，例如，wcstombs()把宽UTF-16转为-8字符串
Xbox几乎完全采用WCS字符串，然后UTF-16编码有点浪费内存，因此各游戏引擎可能采用不同处理方式。
其他：音频片段，包括录制语音，也需要翻译，纹理中可能也会绘进英文文字，也需要翻译。
本地化系统中，最关键的组件是储存人类可读字符串的数据库，以及在游戏运行时，用标识符查找那些字符串的系统。
引擎配置：
文本配置文件：现在最常见的读/写配置选项的方法就是，把选项置于一个或多个文本文件。
经压缩二进制文件，Windows注册表，命令行选项，环境变量，线上用户设定档。
个别用户选项：Windows游戏有时候把个别用户选项储存至注册表中，注册表以树的形式构成

资源及文件系统：
游戏本质上是多媒体体验，载入及管理多种媒体，是游戏引擎必备的能力。媒体包括：纹理贴图，三维网格数据，动画
音频片段，碰撞和物理数据，游戏世界布局等多种类型，除此之外，由于内存空间通常不足，游戏引擎确保在同一时间
每个媒体文件只可载入一份，例如：5个网格模型都共享一张纹理，那么该纹理在内存中只应有1份，多数游戏引擎会
采用某种类型的资源管理器（资产管理器/媒体管理器），载入并管理构成现代三维游戏所需的无数资源。
每个资源管理器都会大量使用文件系统，在PC中，程序员通过操作系统调用的程序库存取文件系统的。然而，游戏引擎
有时候会“包装”原生的文件系统API，称为引擎私有的API，其主要原因有二：1.引擎可能需要跨平台，此需求下，引擎
自己的文件系统API就能对系统其他部分产生隔离作用，隐藏不同目标平台之间的区别。2.操作系统的文件系统API未必
能提供游戏引擎所需的功能。例如 ，许多引擎支持串流（即能够在游戏运行中，同时载入数据），但多数操作系统不直接
提供流功能的文件系统API。游戏机用的游戏引擎也要提供多种可移动和不可移动的储存媒体。
文件系统：
游戏引擎的文件系统API通常提供以下几类功能：1.操作文件名和路径2.开关读写个别文件3.扫描目录下的内容4.处理异步
文件输入/输出请求
UNIX使用正斜线符/作为路径分隔符，而DOS及早期Windows采用\，较新版本Windows都支持正反。
Mac OS 8和9采用：作为路径分隔符，而MacOS X基于UNIX
Windows，远端网络分享可以挂接成为像本机磁盘一样，或是可以用双反斜号加上远端计算机名字和分享目录/资源名字指明。
DOS和早期Windows下，文件名最多只能包含8个字符。
搜寻路径，不要混淆路径和搜寻路径这两个术语。路径是代表文件系统下某文件或目录的字符串，搜寻路径是含一串路径
的字符串，有些游戏引擎会使用搜寻路劲找资源文件
路径API：路径显然比简单字符串复杂的多，程序员需要对路径进行多种操作，Windows为此提供了一组API，由
shlwapi.dll动态程序库实现，并提供shlwapi.h头文件。shlwapi只能用于32位平台。
许多游戏引擎都会把文件IO API包装成自定义的IO函数，最少3个好处：1.引擎程序员能保证这些自定义API在所有
目标平台上均有相同行为，2.API可以简化，3.可提供延伸功能。
C标准库的两种文件IO库都是同步的，程序发出IO请求以后，必须等待读写数据完毕，程序才能继续进行。
异步文件IO，最常见的串流数据类型可能是音频和纹理，但其他数据也可以串流，例如几何图形，关卡布局，动画片段等
为了支持串流，必须使用异步IO，有些操作系统自带异步文件IO库，例如Windows的CLR（common language runtime）
（Visual Basic.Net，C#，managed C++及J#等语言采用的虚拟机器）提供了System.IO.Begin Read（）及System
.UI.Begin Write（）等函数。
优先权：必须谨记文件IO是实时系统，如同游戏的其他部分也要遵循时限，异步IO操作常有不同的优先权，
例如当要从硬盘或蓝光光盘串流音频，并要在串流时播放，那么载满下个音频缓冲的优先权，和载入纹理或游戏关卡块
的优先权相比，前者显然高于后者，异步IO必须能暂停较低优先权的请求，才可以让较高优先权的IO请求有机会在时限前完成
异步文件IO如何工作：利用另一线程处理IO请求。主线程调用异步函数时，会把请求放入一个队列，并立即传回。
若主线程选择等待完成IO请求，就会使用信号量处理。

资源管理器：
资源数据库：对于大部分资产，游戏引擎不会使用其原本的格式，资产需要经过一些资产调节管道（ACP），用来把
资产转换为引擎所需的格式。
无论资源数据库采用什么形式，必须提供以下的功能：
1.能处理多种类型的资源，理想地是以一致的方式处理。2.能创建新资源3.能删除资源4.能查看及修改现存的资源
5.能把资源从一个位置移至磁盘上另一个位置，能让资源交叉引用其他资源，交叉引用通常同时驱动资源管理生成过程
及运行时的载入过程。6.能维持数据库内所有交叉引用的引用完整性。7.能保存版本历史，并含完整日志记录改动者及事由
8.若能支持不同形式的搜寻及查询，将十分有用
资产调节管道：ACP有时也称为工具链
每个资源管道的开端都是DCC原生格式的源文件，经过3个处理阶段，才能达到游戏引擎：
1.导出器，2.资源编译器3.资源链接器
资源依赖关系及生成规则：生成依赖不单围绕资产本身的改动，也关系到数据格式的改动，例如，若储存三角形网格的
文件格式改变了，那么整个游戏中的所有网格就要重新导出并重新生成。有些游戏引擎使用的数据格式，能强健地应付
版本改动。此方针的坏处在于，资源文件和代码都会趋于臃肿，若数据格式改动相对较少，当改动数据格式时，最好
还是硬着头皮重新处理所有文件。每个ACP都需要一组规则来描述资产间的依赖关系。
运行时资源管理：
运行时资源管理器的责任：1.确保任何时候，同一个资源在内存中只有一份副本2.管理每个资源的生命期
3.处理复合资源的载入 4.维护引用完整性 （内部和外部）5.管理资源载入后的内存用量。6.容许按资源类型，载入资源
后执行自定义的处理，这种有时候又称为资源登录或资源载入初始化。7.通常提供单一统一接口管理多种资源类型
8.若引擎支持，则要处理串流
资源文件及目录结构：在一些游戏引擎中，每个资源储存为磁盘上的独立文件，这些文件通常位于树状目录中，
而目录的组织主要是由资产创作者为方便而设计的。游戏引擎通常不会理会资源被放置于资源树的哪个位置。
从文件载入数据时，三大开销为寻道时间（把磁头移动至物理媒体上正确位置的时间），开启每个文件的时间，
及从文件读入数据至内存的时间。使用单一大文件，这些开销都能降至最低。
资源文件格式：例如纹理通常储存为TARGA文件（TGA），便携式网络图形（PNG），标记图像文件格式（TIFF）
联合图像专家小组（JPEG），视窗位图（BMP）文件，DirectX的S3纹理压缩家族格式（S3TC，又称DXTn或DXTC）
资源全局统一标识符：GUID（全局唯一标识符），最常见的GUID选项就是资源的文件系统路径，这种GUID很直觉
因为它直接映射每个资源至硬盘上的物理文件，确保在整个游戏中是唯一的。
为了保证任何时间，载入内存的每个资源只会有一份副本，大部分资源管理器都含某种形式的资源注册表，记录已载入
的资源，最简单的实现模式就是使用字典，即键值对的集合。键为资源的唯一标识符，值通常是指向内存中资源的指针
若请求来自运行中的游戏过程，载入资源可能对游戏帧率造成非常明显的影响，甚至是几秒的停顿，因此，引擎可采取
以下两个取代手法。1.在游戏进行时，完全禁止加载资源  2.资源以异步形式加载
资源生命期：定义为该资源载入内存后至内存被归坏做其他用处之间的时段，资源管理器的职责之一就是管理资源生命期
可能是自动的，也可能是通过对游戏提供所需的API，供手动管理资源生命期。
每个资源对生命期各有不同需求：1.有些资源在游戏开始时便必须载入，并驻留在内存直至整个游戏结束。这些资源有时
称为载入并驻留（load and stay resident LSR）整个游戏中，玩家一直听到或看到的任何资源都应该归为LSR资源
2.有些资源的生命期能对应某游戏关卡。3.有些资源的生命期短于其所在关卡时间4.有些资源如背景音乐，环境音效，
或全屏电影，可以在播放时即使串流。某资源在何时载入，解决方案之一是对资源使用引用计数。
资源管理会遇到的主要难题在于，载入/卸下资源时避免形成内存碎片。
一些常用的解决方案：基于堆的资源分配（简单地忽略内存碎片问题，若你的游戏运行在PC上，操作系统支持高级的虚拟内存分配），
基于堆栈的资源分配（游戏启动时，先分配给载入并驻留资源），基于池的资源分配
使用全局统一标识符做交叉引用：把交叉引用储存为字符串或散列码，内含被引用对象的唯一标识符，意味着每个可能
被引用的资源对象，都必须具有全局唯一标识符。载入后初始化：1.在某些情况下，载入后初始化是无法避免的操作
2.其他情况下，载入后初始化的处理过程是可避免的，但为了方便起见成为权宜之策。


游戏循环及实时模拟：
渲染循环：在GUI中，画面上大部分的内容是静止不动的。在某一时刻，只有少部分的视窗会主动更新其外貌，
因此，传统上绘画GUI界面会利用一个称为矩形失效的技术，仅让屏幕中有改动的内容重绘，较老的二维游戏采用相似的
技术，尽量降低需重画的像素数目。
实时三维计算机图形以完全另一方式实现，当摄像机在三维场景中移动时，屏幕或视窗上的一切内容都会不断改变，因此
不能使用失效矩阵法，取而代之，采用和电影相同的方式产生运动的错觉和互动性。要在屏幕上快速连续地显示一串
静止影像，需要一个循环。在实时渲染应用中，此循环又称为渲染循环。
游戏循环：多数游戏引擎子系统都需要周期性地提供服务，然而，这些子系统所需的服务频率各有不同，
动画子系统通常需要30/60Hz更新率，为了和渲染子系统同步。动力学模拟可能实际需要更频繁地更新（120Hz），
更高级的系统，如人工智能，就可能只需要每次1/2次更新，并且完全不需要和渲染循环同步。
有许多不同方法能实现游戏子系统的周期性更新，我们即将 探讨一些可行的架构方案，首先，以最简单的方法更新引擎
子系统--采用单一循环更新所有子系统，这种循环常称为游戏循环。
游戏循环的架构风格：1.视窗消息泵（Windows的游戏有段代码叫消息泵，先处理来自W..的消息，无消息才执行引擎任务）
2.回调驱动框架（多数游戏引擎子系统和第三方游戏中间套件都是以程序库（函数或类）/框架的方式构成的）
3.基于事件的更新：事件是指游戏状态或游戏环境状态的有趣改变。有些游戏引擎会使用事件系统来对所有/部分子系统
进行周期性更新，要实现这种方式，事件系统必须容许发送未来的事件。（事件可以先置于队列，稍后才取出处理）
游戏引擎在实现周期性更新时，只需要简单地加入事件，在事件处理器中，代码便能以任何所需的周期进行更新。

抽象时间线：
真实时间：我们可以直接使用CPU的高分辨率计时寄存器来度量时间，这种时间在所谓的真实时间线上，此时间线的原点
定义为计算机上次启动或重置之时。这种时间的度量单位是CPU周期，只要简单地乘以CPU的高分辨率计时器频率，
此单位可以转换为秒数。
游戏时间：此时间线在技术上来说独立于真实时间。一般游戏时间和真实时间是相同的。暂停或减慢游戏时间也是非常
有用的调试工具，在追查不正常的渲染时，开发者可以暂停游戏时间，使所有动作冻结。同一时间，渲染引擎及调试
用的飞行摄像机继续运作，只要它们采用另一个时钟。

测量及处理时间：
帧率及时间增量：实现 游戏的帧率是指一连串三维帧以多快的速度向观众显示，帧率的单位为赫兹Hz，即每秒的周期
数量，在游戏和电影里，帧率通常以每秒帧数FPS来度量。其意义和赫兹完全相等。
两帧之间所经过的时间称为帧时间，时间增量，或增量时间（delta time）。Δt应该称为帧周期，因为它是帧频率的倒数
受CPU影响的早期游戏：早期程序员会完全忽略Δ，代替用米每帧设定速率。换言之，那些程序员以Δx=vΔt设定速率
而非使用v。造成的后果就是，游戏中物体看上去的速度完全依赖于运行机器能产生的帧率，受CPU速度影响
基于经过时间的更新：要开发和CPU速度脱钩的游戏，我们必须以某些方法度量Δt，而非简单地忽略它。量度Δt并非难事，
只需读取CPU的高分辨率计时器取值两次——一次于帧开始之时，一次于结束之时。然后取两者之差，就能精确量度
上一帧的Δt，之后，Δt就能供所有引擎子系统使用，或可把此值传给游戏循环中调用到的函数，或把此值变成全局变量。
许多游戏引擎都会使用以上所说的方法，事实上，绝大部分游戏引擎都使用以上的办法。然而，此方法有一大问题，
我们使用第k帧量度出来的Δt去估计接着的第k+1帧的所需时间，这么做不一定准确，下一帧可能因为某些原因，比本帧
消耗更多/少时间，我们称此类事件为帧率尖峰。
使用移动平均，计算连续几帧的平均时间，用来估计下一帧的Δt。此方法能使游戏适应转变中的帧率，同时缓和瞬间
效能尖峰所带来的影响。平均的帧数越多，游戏对帧率转变的应变能力就越小，但受尖峰的影响也会变得越小。
调控帧率：使用上一帧的Δt估计本帧的经过时间，此做法带来的误差问题是可以避免的，只要我们把问题反转过来考虑
与其尝试估算下一帧的经过时间，不如尝试保证每帧都准确耗时。为达到此目标，我们仍然要量度本帧的消耗。
如果耗时比理想时间还短，让主线程休眠，直至到达目的时间。若量度到的耗时比理想时间长，那么只好白等下一个
目标时间，此方法称为帧率调控。
使帧率连续维持稳定，对游戏多方面都很重要，有些引擎系统，例如物理模拟中使用的数值积分，以固定时间更新运作
最佳，稳定帧率也会比较好看，更新视频的速率若不配合屏幕的刷新率会导致画面撕裂，而稳定帧可避免画面撕裂发生。
除此之外。当帧率连续维持稳定，一些如游戏录播功能就会变得更可靠，游戏录播功能，能把玩家的游戏过程录制下来，
之后再精确地回放出来。此功能既是供玩家用的有趣功能，也是非常有用的测试和调试工具。例如，一些难以找到的缺陷
可以通过游戏录播功能轻易重现。为了实现游戏录播功能，需要记录游戏进行时的所有相关事件，并把这些事件及其
时间戳储存下来，然后在播放时，使用相同的初始条件和随机种子，就能准确地按时间重播那些事件。理论上，这么做
能产生和原来游戏过程一模一样的重播，然而，若帧率不稳定，事情可能以不完全相同的次序发生，造成一些”漂移“。
很快就会使原来在后退的AI角色变成在攻击状态中。
垂直消隐区间：有一种显示异常，称为画面撕裂。是由于CRT显示器的电子枪在扫描中途交换背景缓冲区和前景缓冲区
所引致，当产生画面撕裂，许多渲染引擎会在交换缓冲区之前，等待显示器的垂直消隐区间。
等待垂直消隐区间是另一种帧率调控，实际上它能限制主游戏循环的帧率，使其必然为屏幕刷新率的倍数。
使用高分辨率计时器测量实时：我们已经谈及许多有关量度每帧所经过的真实”挂钟时间“
time()的分辨率为秒，游戏每帧消耗仅毫秒，量度分辨率太粗糙。
所有现代CPU都含有高分辨率计时器，通常会实现为硬件寄存器，计算自启动或重置计算机之后总共经过的CPU周期
数目，量度游戏中经过的时间该使用这种计时器，因为其分辨率通常是几个CPU周期时间内的级数。
大多数CPU的高分辨率计时器都是64位的，以免经常造成计时器溢出归零。大约是1.8*10的19次方，195年才会溢出。
对比之下，32位整数时钟在3GHz下约每1.4s就会溢出归零。
高分辨率计时器的漂移：在某些情况下高分辨率计时器也会造成不精确的时间测量。例如，在一些多核处理器中，
每个核有其独立高分辨率计时器，这些计时器可能彼此漂移。若比较不同核读取的绝对计算器读数，可能会出现一些
奇异情况——甚至是负数的经过时间。对于这种问题必须加倍留神。
时间单位和时钟变量。1.应使用什么时间单位，2.应该用什么数据类型储存时间。（64位，32位整数，32位浮点数）
64位整数时钟：我们之前已谈及以时间周期量度的64位无符号整数时钟，它同时支持非常高的精度及很大的数值范围
（3GHz CPU上每周期是0.333ns，CPU约195年才循环一次）
32位整数时钟：当要量度高精度但较短的时间，就可以用机器周期量度32位整数时钟。注意我们仍然使用64位整数变量
储存原始的时间量度，只有持续时间dt才用32位变量储存。这么做可以避免一些整数溢出问题。
32位浮点时钟：把较小的持续时间以秒为单位储存为浮点数，实现方法就是把CPU周期为单位的时间度量除以CPU时钟
频率。我们必须先使用64位的时间相减，之后才把两者之差转换位浮点格式，这样能避免把很大数值储存进32位浮点数中
浮点时钟的极限：我们必须小心，避免使用浮点时钟变量储存很长的持续时间，若使用浮点变量储存自游戏开始至今
的数秒，最后会变得极不准确，无法使用。最多能量度几分钟，更常见的是用来储存单帧或更短的时间，若在游戏中
使用储存绝对值的浮点时钟，便需要定期将其重置为零，以免累加至很大的数值。
其他时间单位：一个常见的选择是1/300s为时间单位，几个优点：1.在许多情况下足够精确 2.约165.7天溢出
3.同时是NTSC和PAL刷新率的倍数，在60FPS下，每帧就是5个这种单位，50FPS下，每帧就是6个这样的单位。
应付断点：当游戏在运行时遇到断点，游戏循环便会暂停，由调试器接手控制。然而CPU还在运行，实时时钟仍然会继续
累计周期次数，当程序员在断点里查看代码时，挂钟时间同时大量流逝，直至程序员继续执行程序时，该帧的持续时间
才可能会量度为几秒，几分钟，甚至几小时！
有一个简单的方法可以避开此问题，在主游戏循环中，若量度到某帧的持续时间超过预设的上限，则可假设游戏刚从
刚从断点恢复执行，于是我们把增量时间人工地设为1/30s或1/60s。结果是，游戏在一帧里锁定了增量时间，避免了一个
巨大的帧时间量度尖峰。
一个简单的时钟类：有些游戏引擎会把时间变量封装为一个类。引擎可能含此类的数个实例----一个用作表示真实”
挂钟时间“，另一个表示”游戏时间（可以暂停，相对真实时间快/慢）“.....
时钟类通常含有一个变量，负责记录自时钟创建以来经过的绝对时间，如上文所述，选择合适的数据类型和单位储存此
变量，至关重要。在以下例子中，笔者使用和CPU相同的储存绝对时间方法——以机器周期为单位的64位无符号整数
时钟类也可以支持一些很棒的特性，如时间缩放。只需把量度得来的时间增量先乘以时间缩放因子，然后才进时钟变量
多处理器的游戏循环：
SIMD，多数现代的cpu都会提供单指令多数据指令集。这类指令能让一个运算同时执行于多个数据之上，此乃一种
细粒度形式的硬件并行。CPU一般提供几类不同的SIMD指令，然而游戏中最常用的是并行操作4个32位浮点数值的指令
因为相比单指令单数据指令，这种SIMD指令能使三维矢量和矩阵数学的运算加速至4倍
把现存三位数学代码改为使用SIMD指令可能会有点棘手，若原来的代码使用到封装良好的三维数学库，那么转换至SIMD
的工作会容易很多。
分叉及汇合：另一种使用多核或多处理器硬件的方法是，采用并行的分治算法，通常称为分叉/汇合法。
其基本原理是把一个单位的工作分割成更小的子单位，再把这些工作量分配到多个核或硬件线程，最后待所有工作完成
后再合并结果。其产生的架构看上去核单线程游戏循环很相似，但是更新的几个主要阶段都能并行化。
每个子系统运行于独立线程：把每个引擎子系统置于独立线程上运行，主控线程负责控制及同步这些子系统的次级子系统
，并继续应付游戏的大部分高级逻辑。
作业模型：使用多线程问题之一是，每个线程都代表相对较粗粒度的工作量，这么做会限制系统中多个处理器的利用率
一种方式：让游戏引擎把工作分割成多个较小，比较独立的作业。
异步程序处理：为了利用多处理器硬件而编写或更新游戏引擎，程序员必须小心设计异步方式的代码。
这里所谓的异步，指发出请求后，通常不能立即得到结果。而平时的同步设计，就是程序等待结果之后才继续执行。
网络多人游戏循环：
主从式模式：大部分游戏逻辑运行在单个服务器上。多个客户端可连接至服务器，以一起参加线上游戏。客户端基本上
只是一个非智能渲染引擎，客户端会读取人体学接口设备数据，以及控制本地的玩家角色。客户端渲染什么，都要服务器之
客户端代码需要即使把玩家的输入转换成玩家角色在屏幕前的动作，不然，玩家会觉得自己控制的游戏角色反应非常
缓慢，恼人，除了这些称为玩家预测的代码，客户端通常仅为渲染核音频引擎，加上一些网络代码。
服务器可以单独运行于一个机器上，此运行方式称为专属服务模式。然而，客户端和服务器不一定要运行于两个独立的
机器上，其实客户端同时运行服务器也是十分普遍的。实际上，许多主从式多人游戏中，单人游戏就是退化的多人游戏
，当中只有一个客户端，并且与服务器同一个机器上，称为客户端于服务器之上的模式。
主从多人游戏的游戏循环有多种不同的实现方法，1.两者可分别实现为完全独立的行程（即不同应用程序），2.把两者
置于同一行程内的两个独立线程。当采用客户端置于服务器之上模式，会带来不少本地通信方面的额外开销，因此，
许多多人游戏会把客户端和服务器置于单个线程中，并由单个游戏循环控制。客户端和服务器可能以不同的频率进行更新
点对点模式：在点对点多人架构中，线上世界的每部机器都有点像服务器，也有点像客户端。因此，每个机器对其拥有
管辖权的对象如同服务器，无管辖权的如同客户端，只负责渲染由对象的远端管辖者所提供的状态。
点对点多人游戏循环的结构比主从游戏的简单的多，从高级的角度来看，点对点多人游戏循环的结构和单人游戏的相似
主从模式中，较能清楚知道哪些代码运行于服务器，哪些运行于客户端。点对点架构中：许多代码都要处理两个可能的
情况，本地机器拥有某对象状态的管辖权，或本地某对象只是有其管辖权远端机器的哑代理。此两种模式通常实现为
两种游戏对象，一种是本机有管辖权的完整”真实“游戏对象，另一种是代理版本，仅含远程对象状态的最小子集

				第八章  	人体学接口设备（HID）
游戏是有互动性的计算机模拟。
人体学接口设备的接口技术：
轮询：一些简单设备，如手柄和老式摇杆，可通过定期轮询硬件来读取输入。那就意味着明确地查询设备的状态，
方法其一是直接读取硬件寄存器，其二是读取经内存映射的IO端口，或是通过较高级的软件接口（该接口再转而读取
适当的寄存器或内存映射的IO端口）。
中断：有些HID只会当其状态有某些改变时，才会把数据传至游戏引擎，例如只有鼠标移动时才需要传送数据，不动
不传送。这类设备通常和主机以硬件中断方式通信，所谓中断是由硬件生成的信号，能让cpu暂停主程序，并执行一小段
称为中断服务程序（ISR的代码），中断能应用再各个方面，但以HID来说，ISR代码大概就是用来读取设备状态，把
状态储存以供后续处理，然后交还cpu给主程序，游戏引擎可以在合适的时候提取那些数据。
无线设备：软件必须以蓝牙协议和设备“交流”，软件可请求HID传送输入数据回主机，或传送输出至设备，这种通信
一般会由游戏引擎主线程以外的线程负责处理，或至少被封装为相对简单的接口供主循环调用。从游戏程序员的角度，
蓝牙设备的状态和其他传统轮询设备的状态并无二致。
输入类型：
1.数字式按钮：几乎每个HID都至少有几个数字式按钮，只有两个状态，向下/上。
2.模拟式轴及按钮：指可获取一个范围以内的数值，而非仅0和1，此类输入通常用来代表扣压扳机的程序，或遥杆的二维
位置，由于模拟式输入经常用来代表某些轴的旋转角度，所以模拟式输入又称为模拟式轴，或简称为轴。
有些设别的按钮也是模拟式的，这意味着游戏能检测玩家按下那些按钮的压强。然而，这些按钮所产生的信号通常有
太多噪声，导致这些按钮不太有用。
模拟式输入到达游戏引擎时并非是模拟的，每个模拟式输入信号通常都要被数字化，意指信号被量化，再被表示为软件
中的整数。
相对性轴：模拟式的按钮，扳机，摇杆和拇指摇杆的位置都是相对的，然而，例如鼠标，鼠标滚轮和轨迹球都是绝对的
加速计，摄像机。
输出类型：HID通常用来把玩家的输入传送至游戏软件，然而有些HID也可以通过各类型输出，向玩家反馈。
1.震动反馈2.力反馈3.音频4.其他输入/输出
游戏引擎的人体学接口设备系统：典型需求：1.死区2.模拟信号过滤3.事件检测4.检测按钮的序列5.手势检测
6.为多位玩家管理多个HID7.多平台的HID支持8.控制器输入的重新映射9.上下文相关输入10.临时禁用某些输入
输入事件检测：许多时候，游戏需要检测事件——即状态之改变，而非每帧的当前状态。
检测按钮状态改变的最简单方法就是，记录上一帧的状态和本帧状态进行比较。此过程可以使用简单的位运算符来检测
弦：是指一组按钮，当同时按下的时候，会产生在游戏中另一个独特行为。以下是一些弦的例子。
弦的检测在理论上颇简单，监察两个或以上的按钮状态，当该组按钮全部同时被按下，才执行操作。
但是还有很多细节需要处理，若弦里的按钮在游戏中有其他用途，便要小心地避免同时产生个别按钮的动作和弦的动作
通常可以这样解决，检测个别按钮的同时，同时检查弦里其他按键并没有被按下。
另一个美中不足的地方，在于人类总非完美，通常按下弦中的某一个按钮早于其他按钮，因此弦的检测代码必须更健壮
处理玩家可能在第i帧按下一个或数个按钮，而在第n+1帧按下弦的其他按钮。
可以把按钮输入设计为：弦总是作用于某个按钮的动作再加上额外的动作。可以在个别按钮按下后，加入一段延迟时间
可以在按下按钮时检测弦，但当之后释放按钮时才产生效果，可以在按下单个按钮时立即执行其动作，但容许这些动作
之后弦的动作所抢占。
序列和手势检测：在实际按下按钮后，程序延迟一段时间才算把它算作一个按下按钮，此过程乃手势检测的特例。
迅速连打按钮，许多游戏要求玩家迅速连打按钮以执行某些动作，连打按钮的频率有时候会转化为游戏内某些数值
多按钮序列，旋转摇杆。
多HID和多玩家的管理，在玩多人游戏时，多数游戏机器容许接上两个或更多个HID。引擎需要跟踪目前连接了哪些
设备，并把每个设备的输入发送给游戏中适当的玩家。这意味着，我们需要某方式映射控制器至玩家。这也许简单到
只是控制器索引至玩家索引的一一映射，也许是更复杂的，例如把控制器映射至按下Start按钮的玩家。
即使在单人游戏，仅有一个HID的情况下，引擎也需要稳健地处理多种异常情形，例如意外地拔掉控制器，或控制器
电池耗尽。当控制器断线，多数游戏会暂停进度，显示信息，然后等待控制器重新连接。大部分多人游戏中，对应断线
控制器的化身会被暂停或临时移除，但容许其他玩家继续玩，当重新连接控制器之后就会再次激活该化身。
若系统中有使用电池运作的HID，游戏或操作系统便需要负责检测低电力状况，出现这种情况时，通常要用某些方法
通知玩家，例如显示一个不会被游戏内容遮挡的信息，及/或播放一个音效。
输入的重新映射：在物理HID的控制功能上，很多游戏提供玩家某程度的选择权，在视频游戏中有一常见选项，就是
决定右拇指摇杆的垂直轴对于摄像机控制的意义。有一句名言“计算机科学中的每个问题都可以用一间接层解决”
我们可以给每个游戏功能一个唯一标识符，然后加一个简单的表，把每个物理或抽象的控制索引映射至游戏中的逻辑功能
每当游戏要判断是否应激活某个逻辑游戏功能，就可以查表找到对应的抽象或物理控制标识符，再而读取该控制的状态
要改变映射，可以更换整个表，或是让玩家设置该表中的个别条目。

上下文相关控制：在许多游戏里，一个物理控制会根据上下文有着不同功能。例子之一就是无处不在的“使用”按钮。
若游戏角色附近有一个物体，按“使用”按钮可能会令角色拾起该物体。另一个常见例子就是模态控制模式，当玩家
走动时，一些控制是用来导航和操控摄像机的。当玩家驾驶载具时，那些控制就会用来操控载具的转向，而摄像机的
操控方式也可能不同。上下文相关控制简单地采用状态机来实现，根据当前状态，个别HID控制可能有不同用途，而最
棘手的部分，就是要判断现时在哪个状态中，例如，当按下上下文相关的“使用”按钮时，角色可能站立的位置，刚好
与一件武器和一个医疗包距离相等，并面向两物体的中间点，那么，应该拾取哪一个物体呢，有些游戏实现了优先系统
另一个相关概念是控制拥有权。有些HID上的控制可能由游戏中不同部分所“拥有”。
禁止输入：在多数游戏中，有时候需要禁止玩家控制其角色。一个较拙劣的方法是，使用位掩码禁用设备上的个别控制。
每当读取控制时，检查该掩码中对应的位，若该位被设置则传回零值或中性值。

第九章 	调试及开发工具
日志及跟踪：printf调试法
使用Output Debug String（）做格式化输出。Win32的这个函数能有效地把调试信息打印至Visual Studio的调试窗口
与printf不同，OutputDebugString（）不支持格式化输出，只能打印char数组形式的字符串，注意上述代码实现了两个
函数：DebugPrintF（）接受用可变长度参数表，而VDebugPrintF（）则接受va_list参数。那么程序员可基于VDebug
PrintF（）来编写其他打印函数。（C/C++不能把省略号的内容由一个函数传递至另一个函数，但传递va_list没问题）
冗长级别：当你成功在代码中策略地加入一堆打印语句，最好能保留这些语句，做日后需要时之用，为此，多数引擎会
提供一些机制来控制冗长级别，例如通过命令行或在运行时动态设定，当冗长级别位0时，只有严重错误消息才会被打印
若把荣誉级别提高，则代码中更多的打印语句会做输出。
频道：把调试输出分类为频道是另一个极为有用的功能。如某频道接收动画系统的消息，而另一频道接受物理系统的消息
可以把调试输出送到14个不同的TTY窗口之一，此外，每条消息还会抄送至一个特别的TTY窗口，使其包含其他14个窗口
的所有输出。那么开发人员就能很容易地重点查看某一类消息，如要追查动画问题，就可以切换至动画的TTY窗口，忽略
其他输出。另外，可以实现过滤器，这些过滤器能在运行时开关，并可设定仅在某条或某组频道能输出。使用这种功能的
话，若要追查动画问题，可以把除了动画以外的频道过滤掉。只需要在调试打印函数里加入频道参数就可实现这种功能
频道可以用数字表示，但更好用C/C++的enum声明来命名。另一种做法是以字符串或字符串散列标识符来命名频道。
把输出同时抄写至日志文件：这样可以在事后诊断问题所在，要是可行的话， 不管当前的冗长级别及频道过滤为何，
最好把所有调试输出都写进日志文件，当遇到预料以外的问题，就能轻伤地通过查核最近的日志文件以追查问题来源
另一个酌量之事在于，是否每次调用输出函数后都对日志文件清空缓冲，以确保玩一游戏崩溃时日志文件仍会包含
最后的输出，最后一笔打印出来的数据通常对确定崩溃原因起到关键作用，所以我们希望确保日志文件一直都含有
最新的输出。清空输出缓冲可能需要很高的成本，因此以下两种情形才清空缓冲：1.程序的日志量不多，2.你发现在某
平台上确有必要这么做，若认为确有这种需求，可以在引擎配置提供清空缓冲的开关选项。
崩溃报告：有些游戏引擎会在崩溃时放出特别的文本输出或日志文件，多数操作系统都可以设置一个顶层异常处理函数
此函数能捕获大部分的崩溃情形，你可以在此函数中打印各种各样有用的信息，甚至可以考虑把崩溃报告以电邮形式
送交整个程序团队。这样做对程序员有很好的启发性：当他们知道美术和设计团队经常遇到崩溃，就会意识到自己的
调试工作到底有多迫切，崩溃报告可包含多种信息1.崩溃时玩家在的关卡，2.崩溃时玩家角色所在的世界空间位置
3.游戏崩溃时玩家的动画/动作状态，4.崩溃时正在运行的一个/多个脚本5.堆栈跟踪（通过这些机制，你可以在崩溃时，
把堆栈中所有非内联函数的符号打印出来）6.引擎中所有内存分配器的状态（余下的内存大小，内存碎片程度）。7.其他
调试用的绘图功能：
调试绘图API：1.API应该简单且容易使用 2.API应支持一组有用的图元，包括但不限于：1.直线，2.球体，3.点，4.坐标轴
5.包围盒，6.格式化文本。	API应该能控制弹性控制图元如何绘画：1.颜色 2.线的宽度 3.球体半径 4.点的大小，坐标
轴的长度，以及其他预设图元的尺寸。	API应该可以把图元绘画至世界空间，或屏幕空间。世界空间图元适合注释
三维场景的物体。屏幕空间图元则适合显示一些调试信息，如HUD一样不受摄像机位置和方向影响。
API应可旋转是否使用深度测试来绘制图元，应该可以在代码的任何地方调用此API，每个调试图元都应包含其生命期
调试绘图系统应能高效地处理大量的调试图元。
注意绘画函数的名字并非使用动词draw而是add，因为调试图元一般并不是在调用函数后立即绘画的，而是把数据加进
一个列表，在稍后才绘画出来，多数高速的三维渲染引擎都会要求，用一个场景数据结构管理所有视觉元素，使引擎更
高效地渲染，渲染通常在游戏循环未进行。
游戏内置菜单：在游戏进行配置选项，最简单及方便的方法是提供游戏内置菜单系统，游戏内置菜单中的项目可做很多
事情，例如，1.切换全局布尔设定。2.调校全局整数及浮点数值。3.调用一些引擎提供的函数，执行任何任务。
4.开启副菜单，使菜单系统按层阶级管理，以方便浏览。
游戏内置主控台：有些引擎提供游戏内置主控台，或会取代游戏内菜单，或会和菜单并存。游戏内置主控台提供命令式
接口以让用户使用游戏引擎的功能，就如同DOS命令提示符让用户使用Windows操作系统的功能，又如同csh，tcsh，ksh
bash壳层让用户类UNIX的操作系统，与菜单系统相似，游戏引擎主控台可提供一些命令，让开发人员能检视及操控全局
引擎设置，以及执行各种命令。
调试用摄像机和游戏暂停：游戏内置菜单或主控台最好能附带两个重要性能：1.把摄像机从游戏角色分离出来，控制
摄像机在游戏世界里飞驰，以细察场景中的所有环节 2.暂停，恢复暂停，单步执行游戏。当游戏暂停时，必须仍然可能
控制摄像机。实现此功能的方法是，即使游戏的逻辑时钟是暂停的，仍保持执行渲染引擎和摄像机控制系统。
慢动作模式：是另一个极为有用的功能，用以细察动画，粒子效果，物理行为，碰撞行为，人工智能行为等。
此模式也容易实现，假设我们使用一个独立于实现的时钟，来更新所有游戏性元素，那么只要使该时钟的更新速率慢于
正常，就能令游戏进入慢动作模式，也可用来实现快动作模式，可于费时的游戏部分高速移动，更快地走到目标地点。
作弊：在开发和调试游戏时，让用户为了方便而打破游戏规则，是很重要的一件事情，这些功能恰当地命名为作弊。
其他有用的作弊但不限于：不死身，给玩家武器，无尽弹药，选择角色网格。
屏幕截图及录像：引擎也可以为用户提供多种选项，控制如何获取屏幕截图。
1.屏幕截图中是否包含调试用的图形及文本。2.屏幕截图中是否包含HUD元素 3.屏幕截图的分辨率 4. 简单的摄像机动画
有些引擎也会提供全面的录像模式，这些系统以游戏的目标帧率获取屏幕截图，通常这些截图会经离线处理生成如AVI或
MP4格式的视频文件。获取屏幕截图通常是比较慢的操作，部分原因涉及从显存传送帧缓冲至主内存的时间开销，而
另一大原因与图像存盘有关。若希望以实时录像（或至少接近实时），那么几乎必须要把获取后的屏幕截图存至主存的
一个缓冲里去，当缓冲被填满后才把内容存盘（那个时候通常游戏会顿卡）。
游戏内置性能剖析：
游戏是实时系统，要达到及维持高帧率是重要的目标，因此，任何游戏程序员都有职责确保其代码能够在预算内高效
运行。大百分比的代码并不需要优化，而唯一能得悉何处要进行优化的方法，就是量度游戏的性能。为了更方便起见，
许多游戏引擎提供某种形式的游戏内置性能剖析工具。
游戏内置剖析器让程序员标记一些代码段落，并且让程序员将每个段落命名为易懂的名字，然后剖析器会为这些段落
计时，剖析器使用cpu的高分辨率时钟去量度每段代码所花的运行时间，并把数据记录在内存。数据通常能以多种方式
显示，包括原始的周期，以微秒为单位的运行时间，以及相对整帧的运行时间百分比。
层阶式剖析：由命令时语言所写的计算机程序，天生就是层阶式——一个函数调用某函数，该函数又再调用其他函数。
当调试程序时，调用堆栈只显示此树的一个快照，具体来说，调用堆栈显示在此树种，从当前执行的函数到达跟函数
的路径。在C/C++中，根函数一般是main（）或WinMain（），虽然从技术上来说，这些函数是由标准C运行时库里
的启动函数所调用，因此启动函数才是层阶中真正的根。
以层阶形式量度执行时间：许多商用性能剖析工具能自动地在剖析程序的每个函数中加入测控。此功能可以同时量度
在剖析期间每个函数调用的包含执行时间和排他执行时间。包含时间量度函数本身以及其调用的所有子函数的执行时间
排他时间仅量度函数本身所花的时间。此外，有些剖析工具能记录每个函数的调用次数。此仍优化程序时的重要信息，
让你分辨两类耗时的函数，一类是因为每次调用所花的时间长，一类是因为调用了非常多次。以上代码内的PROFILE（）
宏会以一个类去实现，该类的构造函数负责开始计时，而析构函数则停止计时，并以指定的名字记录执行时间。
因此该类只会为其块作用域内的代码计时，这是由于C++的特质，对象进出作用域时会自动构造和析构。

游戏内置的内存统计和泄漏检测：除了运行时性能之外，多数游戏引擎也受目标平台上的内存所限。PC游戏对这方面的
限制最少，因为现时的PC有强大的虚拟内存功能。但即使如此，PC游戏还是会受“最低配置”计算机的内存所限
多数游戏引擎都会实现自定义的内存追踪工具，这些工具使开发人员得知每个引擎子系统花费了多数内存，以及是否有
内存泄漏。当要减少内存使用量以适应目标游戏机或PC类型时，这些信息就可以协助做出明智的决定。
跟踪游戏实际使用了多少内存，是个出奇棘手的任务，读者或许以为只要简单地把malloc/free，new/delete包装为一
对函数或宏，就可以跟踪已分配和已释放的内存。可是，现实非如此简单，原因如下
1.你不能控制他人代码的分配行为：除非自己完全从无到有写操作系统，驱动程序及游戏引擎，否则你的游戏最终
很大机会要链接一些第三方库。多数优良的库会提供内存分配钩子，那么就可用自己的分配器取代库内预设的。但是
一些库并不提供钩子。跟踪引擎用到的每个第三方库所分配的内存，并不容易，但是，若严格筛选第三方库，通常还是可行的
2.内存有不同形式：例如，PC有主内存及显存（主要用作保持几何及纹理数据）两种内存，即使可以自己跟踪在主内存
里进行的内存分配及释放，仍几乎不可能跟踪显存的使用。因为图像API如DirectX会向开发者隐藏显存分配及释放的细节
3.分配器有不同形式，许多游戏使用特殊分配器做不同用途。例如，《神秘海域》引擎含多个分配器：一个全局堆作为
通用分配器；一个供分配游戏对象的堆，因为在游戏世界中会不断产生及销毁游戏对象；一个关卡载入堆，用于分配在
游戏中以流读入的数据，一个堆栈分配器供单帧分配（栈在每帧后自动清空），一个显存分配器以及一个调试用的堆。

第三部分：图形及动画
第10章：渲染引擎
采用深度缓冲的三角形光栅化基础：三维场景渲染的本质涉及以下这几个基本步骤：
1.描述一个虚拟场景（一般是以某数学形式表示的三维表面） 2.定位及定向一个虚拟摄像机3.设置光源4.描述场景中物
体表面的视觉特性。（这些视觉特征决定如何与物体表面产生交互作用）5.求解渲染方程，也叫着色方程。
有多种不同的技术可运行上述的基本渲染步骤，游戏图形一般是以照相写实主义为主要目标，但也有游戏以特别风格为
目标（卡通，炭笔素描等），因此渲染工程师和美术人员通常会把场景的属性描述的尽量真实，并使用尽量接近物理
现实的光传输模型。在此语境下，整个渲染技术的领域，包含了视觉流畅而涉及的实时渲染技术，以及为照相写实主义
而设计但非实时运行的渲染技术。
实时渲染引擎重复地进行上述的步骤，以每秒30/50/60帧的速度显示渲染出来的影像，从而产生运动的错觉。
换句话说，实时渲染引擎以最长33.3ms内产生的每幅影像（以达至30FPS的帧率）。通常实际上可用的时间更少，因为
其他如动画，人工智能，碰撞检测，物理模拟，音频，玩家机制，其他游戏性等引擎系统会耗费时间资源。对比电影渲染
引擎通常要花许多分钟以至于许多小时来渲染1帧，现时实时计算机图形的品质可谓非常惊人。
在电影产业里，表面通常由一些矩形的面片所组成，而每个面片则是由小量的控制点定义的三维样条所构成的。
可使用多种样条，包括Bezier曲面（三次面片），非均匀有理B样条，N面片。用面片建模，有点像用小块的长方形布或
纸糊去遮盖一个雕像。高端电影渲染引擎如Pixar的RenderMan，采用细分曲面定义几何形状。每个表面由控制多边形网格
表示表面，但这些多边形会用CatmullClark算法逐步细分成更小的多边形。
传统来说，游戏开发者会使用三角形网格来为表面建模。三角形是表面的分段线性逼近，如同多条相连的线性分段逼近
一个函数或曲线。
在各种多边形中，实时渲染之所以选用三角形，是因为三角形有以下优点：
1.三角形是最简单的多边形，2.三角形必然是平坦的，3.三角形经多种转换之后仍然维持是三角形，对于仿射变换和透视
转换也成立。4.几乎所有商用图形加速硬件都是为三角形光栅化而设计的。
镶嵌：是指把表面分割为一组离散多边形的过程，这些多边形通常是三角形或四边形，三角化专指把表面镶嵌为三角形。
这种三角形网格在游戏中有一常见问题，就是其镶嵌程度是由制作的美术人员决定的，不能中途改变，固定的镶嵌
会使物体的轮廓边缘显得不圆滑，此问题在摄像机接近物体的时候更加明显。
游戏开发者经常尝试以一串不同版本的三角形网格链去逼近此理想的三角形对像素密度，每一版本称为一个层次细节
（LOD），第一个LOD通常称为LOD 0，代表最高程度的镶嵌，在物体接近摄像机时候用。有些游戏引擎会应用动态
镶嵌技术到可扩展的网格上，例如水面或地形，在这种技术中，网格通常以高度场表示，而高度场则在某种规则栅格
模式上定义。最接近摄像机的网格区域会以栅格的最高分辨率来镶嵌，距摄像机较远的区域则会使用更少的栅格点来
进行镶嵌。
渐进网格是另一种动态镶嵌及层级细节技术。运用此技术时，当物体很接近摄像机时采用单个最高分辨率网格。
当物体自摄像机远离，这个网格就会自动密辅，其方法是把某些棱收缩为点，此过程能自动生成半连续的LOD链。
构造三角形网络，缠绕顺序
三角形由三个顶点的位置矢量定义，此3个矢量设为p1，p2，p3.每条棱的相邻顶点的位置矢量相减，就能得到3条棱的
矢量。e12=p2-p1.....任何两棱的叉积，归一化后就能定义为三角形的单位面法线N：N=e12*e13/|e12*e13|
要知道面法线的方向（即棱叉积的目的），我们需要定义哪一面才是三角形的正面（即物体表面），那一面是背面。
这个可以简单用缠绕顺序来定义，缠绕顺序用来定义表面方向有两种方式，分别是顺时针方向（CW）和逆时针方向（CCW）
多数底层图形API提供基于缠绕顺序来剔除背面三角形，例如，若在Direct3D内把剔除模式参数（D3DRS_CULL）设置
为D3DCULLMODE_CW,那么所有在屏幕空间里为顺时针方向的三角形会视为背面，不被渲染。
背面剔除的重要性在于，我们通常不需要浪费时间渲染看不见的三角形。而且，渲染透明物体的背面还会作为视觉异常
三角形表：定义网格的最简单方法是以每3个顶点为一组列举，当中每3个顶点对应一个三角形。此数据结构称为三角形表
索引化三角形表：由于在三角形表中重复的数据会浪费内存，同时浪费GPU的资源，因为重复的顶点会计算变换及光照
多次，因此，多数渲染引擎采用更有效率的数据结构——索引化三角形表。其基本思想就是每个顶点仅列举一次，然后
用轻量级的顶点索引来定义组成的三角形的3个顶点。在DirectX下顶点储存于顶点缓冲，在OpenGL下则称其为顶点数组
而索引会储存于另一单独缓冲，称为索引缓冲或索引数组。
在游戏渲染中，有时候还会用到两种特殊网格数据结构，分别为三角形带及三角形扇。这两种数据结构不需要索引缓冲，
但同时能降低某程度的顶点重复。
在三角形带中，前3个顶点定义了第一个三角形后，之后的每个顶点都会连接其前两个顶点，产生全新的三角形。为了
统一三角形带的缠绕顺序，产生每个新三角形时，其前两个相邻顶点会互换次序。
在三角形扇中，前3个顶点定义了第一个三角形，之后每个顶点与前一顶点及及该三角形扇的首顶点组成三角形。
顶点缓存优化：当GPU处理索引化三角形表时，每个三角形能引用顶点缓冲内的任何顶点。为了在光栅化阶段保持三角
形的完整性，顶点必须按照其位于三角形中的次序来处理。当顶点着色器处理每个顶点后，其结果会被缓存以供重复使用
使用三角形带及三角形扇，一个原因是能节省内存（无须索引缓冲），另一原因是基于它们往往额能改善gpu存取显存
时的缓存一致性。我们甚至可以使用索引化三角形带及索引化三角形扇以消除所有顶点重复（这样通常比不用索引缓冲更省内存）
而同时仍能受益于三角形带及三角形扇次序所带来的缓存一致性。除了次序受限的三角形带及三角形扇，我们也可以优化
索引三角形表以提升缓存一致性。顶点缓存优化器就是为此而设的一种离线几何处理工具，它能重新排序三角形的次序
以优化缓存内的顶点复用。顶点缓存优化器一般会根据多种因素来进行优化，例如个别gpu类型的顶点缓存大小，gpu
选择缓存或舍弃顶点的算法等。

模型空间：三角形网格的位置矢量，通常会被指定于一个便利的局部坐标系中，此坐标系可以称为模型空间，局部空间
或物体空间。模型空间的原点一般不是物体中心，而是某个便利的位置。
世界空间及网格实例化：使用网格组成完整场景时，会在一个公共的坐标系里放置及定向多个网格，此坐标系称为
世界空间。每个网格可在场景中多次出现，例如，街上排列着同款街灯，一堆看不见面目的士兵，攻击玩家的一大群
蜘蛛等，每个这些物体称为网格实例。
每个网格实例含有共享网格的引用，此外也包含一个变换矩阵，用以把个别实例的网格顶点从模型空间转换至世界空间
此矩阵名为模型至世界矩阵，有时候仅简单称为世界矩阵。
当渲染模型时，模型至世界矩阵也可用来变换网格的表面法矢量，为了正确变换法矢量，必须把法矢量乘以模型至世界
矩阵的逆转置矩阵。有些网格是完全静止及独一无二的，例如建筑物，地形，以及其他背景元素。
描述表面的视觉性质：为了正确地渲染及照明表面，我们需要有描述表面的视觉性质，表面性质包含了几何信息，例如
表面上不同位置的法矢量，表面性质也包括描述光和表面交互作用的方式，包括漫反射颜色，粗糙度/光滑度/反射率/
纹理/透明度/不透明度/折射率等。表面性质也可能含有表面随时间变化的描述。
光和颜色的概论：光的颜色是由其强度I及波长λ所决定的。一束光线可能含单一纯波长，即是彩虹的颜色，又称为光谱
颜色。一束光线可能由多种波长的光混合而成，我们可以把一束光线中各波长的强度绘成图表，这种图称为光谱图。
光只能做4件事情：1.吸收2.反射3.在物体中传播及折射4.衍射。
光能进入半固体的表面，在表面下反弹，再从另一个位置离开表面，这个现象称为次表面散射。此效果能使皮肤，蜡等
物质显示其柔和的特性。
颜色空间和颜色模型：颜色模型是量度颜色的三维坐标系统，而颜色空间是一个具体标准，描述某颜色空间内的数值化
颜色如何映射到人类在真实世界看到的颜色。当颜色存储于位图时，可使用多种不同的颜色格式，颜色格式的定义，部分
由每像素位数（BPP）决定，更具体地说，是由表示每颜色通道的位数决定的。RGB颜色模型中，红绿蓝称为颜色通道。
属性插值：当渲染三角形时，重要的是三角形内点的视觉特性，这些内点最终成为屏幕上的像素，换言之，我们需要
取得每像素的属性，而不是每顶点的。
要取得网格表面的每像素属性，最简单的方法是对每顶点属性进行线性插值。当把线性插值施于顶点颜色，这种属性便
称为高氏着色法（Gouraud shading）
顶点法线及圆滑化：光照是基于物体表面的视觉特性以及到达该表面的光线特性，来计算物体表面上各点的颜色的过程的。
光照网格最简单的方法就是，逐顶点计算表面的颜色。为了计算表面某点的光线反射量，多数光照模型会利用该点垂直于
表面的法矢量。
纹理种类：最常见的纹理种类为漫反射贴图，又称为反照率贴图。其他种类的纹理，包括法线贴图（每个纹素用来储存
以RGB值编码后的法矢量），光泽贴图（在每个纹素上描述表面的光泽程序），环境贴图（含周围环境的图像以渲染反射效果）
纹理坐标可以延伸至[0,1]范围之外，图形硬件可用以下几种方式处理范围以外的纹理坐标。这些纹理坐标称为纹理寻址模式
缠绕模式（纹理在各方向重复又重复），镜像模式（在u为奇数倍数上的纹理会在v轴方向形成镜像，反之），
截取模式（纹理坐标在正常范围之外，纹理的边缘纹素会简单延伸），边缘颜色模式（此模式下用户能指定一个颜色
当纹理坐标在[0,1]范围以外使用）

纹理格式：
纹理位图可在磁盘上储存为任何格式的文件，只要你的游戏引擎含有读取该文件至内存的代码即可。常见的文件格式有
TGA，便携式网络图形PNG，视窗位图BMP，标记图像文件格式TIFF，纹理存于内存时，通常会表示为二维像素数组，
当中像素使用某种颜色格式，多数现在的显卡及图形API都会支持压缩纹理。DX支持一系列称为DXT或S3纹理压缩的格式
显然，压缩纹理的优点是比无压缩纹理使用较少内存，其他的好处还有，比较高效，S3TC纹理能够提速，皆因其内存
存取模式更缓存友好。
纹素密度（纹素和像素之比）及多级渐进纹理：纹素密度并不是一个常量，随物体相对摄像机的距离而改变。纹素密度
影响内存使用量，也影响三维场景的视觉品质。当纹素密度远低于1，每个纹素就会显著比屏幕像素大，开始察觉到纹素
的边缘，毁灭游戏的真实感，当远高于1，许多纹素会影响单个屏幕像素，会产生莫列波纹。更甚至，由于像素边缘内
的多个纹素会按细微的摄像机移动而不断改变像素的颜色，像素的颜色就会显得浮动不定及闪烁。若玩家永不会接近
一些远距离的物体，用非常高的纹素密度渲染那些物体只是浪费内存，毕竟无人能看见细节。
理想地，我们希望无论物体是远是近，仍然维持纹素密度接近1，要准确地维持此约束是不可能的，但可以使用多级
渐进纹理技术来逼近，对于每张纹理，我们建立较低分辨率位图的序列，其中每张位图的宽度和高度都是前张位图的
一半，我们称这些影像为多级渐进纹理或渐远纹理级数。
世界空间纹素密度：也可用于描述纹素和贴图表面的世界空间面积之比。世界空间纹素密度不需要接近1，实际上此
数值许多时候会比1大很多，具体要视乎所选择的世界单位。然而重要的是，在物体贴上纹理时，应使用大概一致的
世界空间纹理密度。
纹理过滤：当渲染纹理三角形上的像素时，图形硬件会计算像素中心落入纹理空间的位置，来对纹理贴图采样。
通常纹素和像素之间并没有一对一的映射，像素中心可以落入纹理空间的任何位置，包括在两个或两个以上纹素之间的
边缘。因此，图形硬件通常需要采样出多于一个纹素，并把采样结果混合以得出实际的采样纹素颜色，此过程称为纹理过滤
多数显卡支持以下的纹理过滤种类：1.最邻近2.双线性（会对围绕像素中心的4个纹素采样，并计算加权平均）
3.三线性（把双线性过滤法施于最接近的两个渐进纹理级数，然后把两个采样结果线性插值）4.各向异性（根据视角，对
一个梯形范围内的纹理采样，借以提高非正对屏幕的纹理表面的视觉品质）
材质：是网格视觉特性的完整描述。包括贴到网格表面的纹理设置，也包含一些高级功能。
BRDF图表：Phong模型中，其3个项是通用的双向反射分布函数之例外，BRDF是沿视线方向的V的向外辐射与沿入射
光线L的进入辐射之比。BRDF可以显示为一个半球图表，当中距原点的径向距离代表从该角度观察到的反射光强度。
Phong的漫反射项为kD（N*L）
光源模型：静态光照
最快的光照计算就是不计算，因此光照最好能尽量在游戏运行前计算，我们可以在网格的顶点预计算Phong反射，并把
结果储存于顶点漫反射颜色属性中，我们也可以逐像素预计算光照，把结果储存于一类名为光照贴图的纹理贴图上。在
运行时，把光照贴图投影在场景中的物体，以显示光源对物体的影响。
观察空间：虚拟摄像机的焦点，是观察空间或称为摄像机空间的三维坐标系统的原点，摄像机位置及定向可以用观察
至世界矩阵表示，如同一个场景中的网格实例使用模型至世界矩阵表示其位置及定向。
双缓冲法：显示硬件扫描一个帧缓冲时，渲染引擎则更新另一个帧缓冲。通过在垂直消隐区间互换两个缓冲，双缓冲
就能确保显示硬件一直能扫描完整的帧缓冲，这么做能避免一个名为撕裂的不良效果，有些引擎使用三缓冲。
全屏抗锯齿FSAA，影像渲染至比实际屏幕宽一倍，高一倍的帧缓冲里。然后再把该帧缓冲缩减采样至所需的分辨率。
FSAA很耗时，因为渲染长宽两倍大小的帧等于渲染4倍像素。也称为超采样抗锯齿（SSAA）
多数现在的图形硬件能够进行抗锯齿渲染，而又不需要实际渲染长度两倍大小的影像，当中用到的技术称为多重采样
抗锯齿（MSAA）。其基本原理是把每个像素分拆为多个片段，这些片段在管道最后阶段结合成单个像素。
由于近年流行的延迟渲染不能使用MSAA，因此多种新的抗锯齿技术应运而生，例如，动态抗锯齿MLAA，方向局部化
抗锯齿DLAA，快速逼近抗锯齿FXAA，次像素重建抗锯齿SRAA等
深度缓冲：有可能发生物体交互穿插，这种问题叫做深度冲突，解决办法有z缓冲和w缓冲，储存的是裁剪空间的坐标
但依观察空间的角度来说，z缓冲储存是1/z，w缓冲储存的是z。
渲染管道：管道化架构的最大优点在于非常适合并行化。
管道的吞吐量量度总体每秒可产生的数据量，而管道的潜伏期量度单个数据需要花费多少时间才能走完整个管道。
个别阶段的潜伏期量度该阶段需花多少时间处理单个数据。
渲染管道概观：我们的管道中，最高级的阶段包括：1.工具阶段（脱机）：定义几何和表面特性。
2.资产调节阶段（脱机）：资产调节管道处理几何和材质数据，生成引擎可用的格式。
3.应用程序阶段（CPU）：识别出潜在可视的网格实例，并把它们及其材质呈交至图形硬件以供渲染。
4.几何阶段（GPU）：把顶点照明，变换然后投影至齐次裁剪空间。可选择用几何着色器处理三角形，然后对三角形
根据平截头体进行裁剪。
5.光栅化阶段（GPU）：把三角形转换为片段，并对片段着色。片段经过多种测试后，最终和帧缓冲混合。
管道的实现：前两个渲染管道阶段以脱机方式实现，应用程序阶段则是由游戏机或PC的主CPU执行。几何及光栅化阶段
通常由图形处理器GPU处理。

工具阶段：三维建模师在数字内容创作DCC软件里制作三维模型。
资产调节阶段也可能会计算高级的场景图数据结构。例如，可能会处理静态关卡几何以生成BSP树（给定摄像机位置及
定向，场景图数据结构能帮助渲染引擎迅速判断哪些物体需要渲染）
耗时的光照计算通常会在脱机时进行，这也是资产调节阶段的一部分，这种计算称为静态光照。静态光照可以计算网格
顶点上的关照颜色（此称为顶点光照“烘培/baking”）也可以把每像素的光照信息存于纹理中，这些纹理称为光照
贴图。除此之外，还可以生成预计算辐射传输（PRT）的系数，这通常是球谐函数的系数。
顶点着色器：处理顶点。片段着色器（像素着色器）：处理片段。
（DX10增加）几何着色器：允许渲染工程师修改剔除和创建整个图元（三角形，线段和点）。
图形硬件已进化成一种专门的微处理器，称为图形处理器。
就是GPU在完全可编程的形式下，gpu也不是通用微处理器，也不应如此。GPU能达至高处理速度的原因，在于仔细
控制管道的数据流。有些管道阶段是完全固定功能的，有些是可配置但不能编程的。内存只能在控制范围里存取，并且
用专门的缓存把不需要的重复计算减至最少。
DX11又增加了外壳着色器，域着色器和计算着色器。前两者用于自定义镶嵌，后者用于GPU通用计算。
GPU管道：
1.顶点着色器：此阶段是完全可编程的。顶点着色器负责变换及着色/光照顶点。此阶段的输入是单个顶点。
图元装配(可)->顶点着色器（可）->几何着色器（可）->（流输出（可）->顶点着色器）/裁剪（可配置）->屏幕映射
（固定）->三角形建立（固定）->三角形遍历（固定）->提前深度测试（可配置）->像素着色器（可）->
合并/ROP（可配置）->帧缓冲（可）。-------可代表可编程，可配置，固定功能。
在较新的gpu中，顶点着色器能完全存取纹理数据，而较旧的gpu只容许像素着色器存取纹理数据。当把纹理作为独立
的数据结构，例如高度图/查找表，此功能特别有用。
流输出：现在的gpu容许把达至此管道阶段的数据写回内存。数据能从那里回到管道之始做进一步处理，此功能称为流
输出。通过使用流输出，许多迷人的视觉效果可以不经cpu实现。其中一个例子就是头发渲染。头发通常是由三次样条
曲线的集合表示的。
自三角形建立阶段，光栅化硬件开始迅速地把三角形转换为片段，此阶段是不能配置的。三角形遍历，三角形遍历阶段
把三角形分解为片段（光栅化）。通常每个像素会产生一个片段，除非使用MSAA，那么每个像素会产生多个片段。
提前深度测试：许多显卡能够在管道的此时间点检查片段的深度，若某片段会被帧缓冲的像素遮挡，就在此丢弃该片段，
这么做对于所有被遮挡片段，能直接跳过（可能非常耗时）像素着色器片段。此阶段称为提前z测试或提前深度测试。
合并/光栅运算阶段：管道的最终阶段为合并阶段或混合阶段。NVIDIA称之为光栅运输阶段。此阶段不能编程但能高度
配置。
内存访问：由于GPU实现了数据处理管道，必须非常谨慎地控制内存访问，着色器程序不能直接读/写内存。取而代之，
其内存访问只限于两个方法：寄存器和纹理贴图。
着色器寄存器：着色器可用寄存器间接地存取内存。
寄存器有以下4大类：1.输入寄存器。2.常数寄存器。3.临时寄存器。4.输出寄存器。
GPU通常会把输出数据储存至缓存，使这些数据能重用而不需要重新计算。例如，变换后顶点缓存是用来储存顶点着色器
最近处理过的结果。
纹理：着色器也能够直接读取纹理贴图，纹理数据是以纹理坐标寻址的，而不是使用绝对内存地址。GPU的纹理采样器
会自动过滤纹理数据，适当地混合相邻纹素及相邻渐远纹理级数的值。也可以关上纹理过滤，以直接存取某纹素的值。
着色器只能用简介方法写数据进纹理——把场景渲染至屏幕外帧缓冲，再在后续的渲染阶段把该帧缓冲当作纹理贴图使用
此功能称为渲染到纹理RTT。
效果文件：一个孤立的着色程序并不十分有用， GPU管道还需要一些额外信息，才能为着色器程序调用提供有意义的输入
为了把多个着色器结合成完整的视觉效果，我们可以使用名为效果文件的文件格式。
不同的渲染引擎会用稍有差异的方式实现这些效果文件。在Cg里，其效果文件格式名为CgFX。OGRE采用和CgFX相似
的格式，名为材质文件。
GPU的管道阶段：应用程序阶段：1.可见性判别2.提交几何图元至GPU以供渲染3.控制着色器参数及渲染状态。
遮挡及潜在可见集：把可见表中完全被其他物体遮挡的物体移除，称为遮挡剔除。大型环境的总体遮挡剔除可以通过
预计算   潜在可见集（PVS）实现。给定一个摄像机位置，PVS能列出可能可见的物体，PVS会不准确地包含一些实际
上不可见的物体，但不会错误地排除一些应该对渲染有贡献的物体。
渲染状态：1.世界观察矩阵2.光源方向矢量3.纹理绑定4.纹理寻址及过滤模式5.基于时间的纹理滚动及其他动画效果。
6.深度测试7.alpha混合选项。
GPU管道内的所有可配置参数称为硬件状态或渲染状态。
状态泄漏：如果在提交图元之间，忘记设置某方面的渲染状态，那么上一图元的设置便会“泄漏”至下一图元。
渲染状态泄漏的结果，可能是物体出现错配的纹理或不正确的光照效果。显然应用程序状态阶段绝不应该产生状态泄漏
把几何物体按材质排序会对渲染性能产生不利影响，因为他会增加覆绘——多个互相重叠的三角形重复填充同一像素
又要按材质排序渲染几何物体，又要从前至后的顺序渲染不透明几何物体，怎样才能排解此冲突？答案是使用GPU的
深度预渲染步骤功能。基本概念是渲染场景两次：第一次尽速产生深度缓冲的内容，第2次才使用完整的颜色填进帧缓冲
当关闭像素着色器并仅更新深度缓冲，GPU便会使用特设的双倍速度的渲染模式。此次渲染步骤中，不透明物体可按
从前至后的顺序渲染，使深度缓冲的写入次数变得最少。然后几何物体按材质来重新排序，用最少的状态改变渲染颜色
使管道吞吐量最大化。
现在的游戏世界能达到非常大的规模，由于在多数场景中，大部分的几何物体会在摄像机平截头体的范围之外，因此，
明确地用平截头体剔除每个这些物体，通常难以置信地耗费时间资源，取而代之，我们希望设计一些数据结构管理场景
中所有几何物体，并能迅速丢弃大量完全不接近摄像机平截头体的世界部分，这样才能进行更仔细的平截头提剔除。
理想地，此数据结构可以帮助对场景中的几何物体排序，排序次序方面，可以为了深度预渲染步骤做前至后或后至前排序
或是为了颜色渲染而采用材质排序。这样的数据结构通常称作场景图，此名称与电影渲染引擎或Maya之类的DCC工具
所采用的数据结构相关。多数这类数据结构的理念在于，把三维空间以某形式划分为区域，使不与平截头体相交的区域
能尽快丢弃，而无须逐一物体进行平截头剔除，这些数据结构的例子有四叉树，八叉树，BSP树，kd树，空间散列技术等
四叉树和八叉树：
四叉树以递归方式把空间分割成象限，每层递归以四叉树的节点表示，每个节点有4个子节点，每个子节点代表一个象限。
这些象限通常是由轴对齐的平面切割而成的，所以每个象限是正方形或长方形的。然而，有些四叉树用任意形状的区域
来细分空间。四叉树可用于储存及组织几乎任何在空间中分布的数据。在渲染引擎中，四叉树通常用来储存可渲染图元
目的是加速平截头体剔除，可渲染图元储存于树的叶节点，我们通常尽量令每个叶节点有均匀的图元数目。
要实现此目标，可以基于区域内的图元数目来决定我们继续或终止细分区域。
八叉树是四叉树的三维版本，在每层递归细分时，八叉树把空间分割成8个子区域。
包围球树：把空间以层次结构分割为球状区域。包围球树的子节点含有场景中可渲染图元的包围球，
BSP树：二元空间分割树把空间递归分割为一半，直接每个半空间里的物体符合某些预定条件，BSP树有多种用途，包括
碰撞检测和构造实体几何CSG，以及其最知名的优化三维图形用途——平截头体剔除及几何物体排序。kd树是BSP树的
特殊清空，BSP树的分割平面可以是任意方向的，而kd树的分割平面会依次序与k维空间的轴对齐。
以渲染应用来说，BSP树在每层递归中用单个平面把空间二分，这些分割平面可以是轴对齐的，但更常用的方法是每次
细分时，都以场景中某三角形的平面分割空间。所有其他三角形就会分成两类，一类在该分割平面之前，另一类在之后
任何与分割平面相交的三角形，都会被分割为3个三角形，使每个三角形都只会在分割平面之前或之后，或是分割平面
共面。
选择场景图：例如读者正在开发格斗游戏，擂台外主要是静态场景，那么这游戏可能根本不需要场景图，若在室内，
BSP树或入口系统可能是不错的选择。若游戏于比较平坦的室外地形上进行，并且场景以俯览为主（或许如实施策略游
戏或上帝模拟游戏的情况），简单的四叉树也许已能达到高效的渲染性能。另一方面，若室外场景主要是以地上角色的
视点观察，就可能需要额外的剔除机制。内容密集场景可受益于遮挡体积（反入口）系统，因为场景中会有许多遮挡物
若你的室外场景较为分散，加入反入口系统或无裨益（甚至有损帧率）。
高级光照及全局光照：
法线贴图：每个纹素代表表面法矢量的方向，利用这种贴图，三维建模师可以为渲染引擎细致地描述表面的形状，而无须
把模型高度镶嵌，使用法线贴图的单个平面三角形， 看上去有如百万个微小三角形做成的效果。法矢量通常会在纹理的
RGB颜色通道中编码，由于RGB颜色通道必须为正数，而法矢量的分量可为负数，所以为法矢量编码时会加上合适的偏
置。假设表面法矢量都是单位矢量，那么有时候只需在纹理中储存两个坐标，第3个坐标能较简易地在运行时计算得出
高度贴图：视差贴图和浮雕贴图。
如字面意思，用来编码高于或低于三角形表面的理想高度，因为每个纹理只需单个高度值，所以高度贴图通常编码为灰阶
影像。通常用于视差贴图法及浮雕贴图技术。这俩技术都能令平面表面显得有强烈的高度变化，能制造出自遮挡及自阴影
的效果。
我们可以把非常细致的镜面信息编码至一张贴图中，此贴图称为镜面贴图。
若我们把ks的值存进镜面贴图的纹素，就能控制每个纹素的位置能造成多少镜面反射。这一种镜面贴图有时会称为光泽
贴图，这种贴图也会称为镜面遮罩，因为0值的纹素能“遮盖”不想要有镜面反射的表面部分。若在镜面贴图储存α的值
那么我们可以控制每纹素位置镜面高光的集中程度，这种纹理称为镜面幂贴图。镜面强度的数学形式：ks（R*V）α。
最常见的两种环境贴图格式是球面环境贴图及立方环境贴图。立方贴图像是从6个主要方向拍摄照片后再拼合而成。
HDR影像的表示方法之一就是，把红绿蓝通道各储存为32位浮点数，而不使用8位整数。
阴影渲染：两个最流行的阴影渲染技巧为阴影体积和阴影贴图。两种技巧都会把场景中的物体分为3个类别：投射阴影
的物体，接收阴影的物体，以及完全被阴影渲染忽略的物体。
阴影体积使用一种特殊的全屏缓冲产生阴影，此缓冲称为模板缓冲，它对应屏幕每个像素储存一个整数值，渲染时可用
模板缓冲作为遮罩，它对应屏幕每个像素储存一个整数值。渲染时可用模板缓冲作为遮罩，例如，我们把GPU配置成
渲染某片段时，仅当模板缓冲中对应的值不是0才进行渲染。此外，也可以配置GPU，使渲染几何物体时以几种不同方式
更新模板缓冲里的值。
阴影贴图：实际上是进行每片段的深度测试，但该“深度”非从摄像机的视角去计算，而是从光源的视角计算，使用
阴影贴图时，需要把场景渲染两次，首先，从光源视角渲染场景，把渲染结果的深度缓冲储存为阴影贴图纹理。然后，
以正常方式渲染场景，渲染每个片段时使用阴影贴图判断该片段是否在阴影内。
阴影贴图仅含深度信息，其每个纹素记录从光源方向来说最近遮挡物的深度，因此，阴影贴图通常会使用硬件的双倍速模式
，仅填充深度缓冲。点光源需要使用透视投影来渲染阴影贴图，而平行光则使用正射投影。
环境遮挡（AO）是一种用于渲染接触阴影的技术，所谓接触阴影是指场景仅以环境光照明时所产生的软阴影。静态物体
的AO可以在脱机时预计算，计算结果通常会储存为纹理。
镜像，焦散（强烈反射或折射所产生的水亮高光，通常出现于非常光滑的表面，如水面或抛光金属），次表面散射（SSS）
次表面散射会令人体皮肤，蜡，大理石等材质表面产生“温暖，淡淡泛光”之效果。SSS可以用比BRDF更高阶一点的变种
表示，此函数称为双向表面散射反射分布函数（BSSRDF）。次表面散射渲染（BRDF光照模型）
预计算辐射传输PRT：是一项较新的技术，可以实时模拟基于辐射度算法的渲染方法，做法是，预先计算来至所有方向
的入射光和表面的互动（反折散射），并把那些描述储存下来，在运行时，根据某入射光查表，并把该光线的反射迅速
地转换为准确的光照结果。
一般来说，光于某点的反射是一个复杂的函数，该函数定义于该点为球心的半球范围。我们需要一个紧凑表示此函数
的方法，才能使PRT技术实用化。常见的方法是用球谐基函数的线性组合逼近此函数。
延迟渲染：一种场景着色方法，主要的光照计算是在屏幕空间进行的，而非观察空间，我们首先迅速地渲染不含光照的
场景。在此阶段，我们把所有用于光照计算的信息储存在一个“深厚的”帧缓冲里，此缓冲称为几何缓冲。完成场景
渲染后，就使用几何缓冲的信息来计算光照和着色。这样做通常比观察空间光照更高效，又避免了着色器版本的增长
并且可以相对容易地渲染一些非常悦目的效果。
视觉效果和覆盖层：至此所谈及的渲染管道，主要是用于渲染三维固体物体的。通常在此渲染管道之上，还有一些专门
渲染视觉效果的渲染系统，例如粒子效果，贴花，头发皮毛，降雨降雪，水以及其他专门的视觉效果。另外，也可应用
全屏后期处理效果，例如晕影（在画面边缘稍模糊的效果），动态模糊，景深模糊，人工性/增强性色彩处理等。
粒子效果：1.粒子系统由大量相对简单的几何物体所组成，通常是称为quad的简单卡片，每个quad由两个三角形组成。
2.几何物体通常是朝向摄像机的 3.其材质几乎都是半透明的 4.粒子以多种丰富方式表现动画 5.粒子通常会不断出生及湮灭
贴花是覆盖在场景中正常物体上，相对较小的几何物体，用于动态改变物体表面的外观。弹孔，脚印，抓痕等都是贴花的粒子
现代引擎最常用的贴画实现方法就是，把贴画设为长方形区域，按某方向投影在场景中。这会形成一个三维空间中的
长方体，长方体在投射方向和表面第一次相交的地方就成为贴花的面片。
环境效果：1.天空 2.地形 3.水体 4.覆盖层 5.阴极射线管CRT显示屏往往有非线性的亮度响应曲线。
全屏后期处理效果：1.动态模糊（产生模糊的方法是把一个卷积核施于影像） 2. 景深模糊 （使用深度缓冲区的内容调整每像素的模糊程序）
3.晕影 （通过降低屏幕四角的亮度和饱和度，产生类似电影的戏剧性效果）4.着色（可用后期处理修改屏幕上颜色）


第11章：动画系统
角色动画的类型：
所有游戏动画技术的前身是传统动画/手绘动画，赛璐璐动画是传统动画的一个种类，赛璐璐是透明的塑料片，上面可以
绘画，电子版本是称为精灵动画的技术。
精灵动画系统是每个四边形贴上一连串纹理位图（动画纹理）以产生动感。
刚性层阶式动画（实现三维角色动画最初的方法），角色由一堆刚性部分建模而成。刚性层阶技术的最大问题在于，
角色的身体会在关节位置产生碍眼的“裂缝”，对于机器人或机械，刚性层阶动画能好好配合，对于“有血有肉”的
角色，仔细查看就会出现问题。
每顶点动画及变形目标：每顶点动画的蛮力技术，在实时游戏中很少会用上此技术。此技术的一个变种——变形目标动
画——应用于一些实时引擎。由动画师移动网格的顶点，仅制作相对少量的固定极端姿势，在运行时把两个或以上的
这些姿势混合，就能生成动画，每个顶点的位置是简单地把每个极端姿势的顶点线性插值（LERP）而得。
变形目标技术通常用于面部动画。因为人脸具有非常复杂的解剖结构
蒙皮动画：随着游戏硬件的能力更进一步，称为蒙皮动画的技术就应运而生了。此技术含有许多每顶点动画及变形目标
动画的优点，允许组成网格的三角形做出变形。但蒙皮动画也有刚性层阶式动画的高校性能及内存使用量特性。蒙皮
动画能产生相当接近真实的皮肤和衣着移动。骨骼是由刚性的“骨头”所建构而成的，这与刚性层阶动画是一样的。
然而，这些刚性的部件并不会渲染显示，始终都是隐藏起来的。称为皮肤的圆滑三角形网格会绑定于骨骼上，其顶点
会追踪关节的移动，蒙皮上每个顶点可按权重绑定至多个关节，因此当关节移动时，蒙皮可以自然地拉伸。
把动画方法视为数据压缩技术。
骨骼由刚性的关节层阶结构所构成，在游戏业界“关节”和“骨头”两个术语会交替使用，游戏引擎并不在意骨头，
只在乎关节，因此在业界听到“骨头”，99%情况实际上是指关节。

量化：另一个降低动画尺寸的方法是缩减每通道的尺寸。浮点小数值正常会储存为32位IEEE格式。然而，在动画片段中
我们经常并不需要保持这种精确度及范围，储存四元数时，可确保其通道值的范围必然是[-1,1]。经验高速我们，四元数
可以仅用16位精确度编码，因此，每通道使用32位浮点数其实白白浪费了16位。
把32位IEEE浮点数转换为n位整数表示法的运算称为量化，实际上此过程运算有两部分：编码是把原来的浮点小数值
转换为量化后的整数表示法的过程，解码是把量化整数还原为原来浮点数的近似值。（我们只能还原一个近似值——
量化是有损压缩），因为它实质上降低了用于表示一个值的精确度位数。
要把浮点数编码成整数，我们首先要把合法范围切割成N个同等大小的区间，然后我们找出某浮点数值属于哪一个区间
并用该区间的整数索引值表示该值。
浮点数标准量化：编码过程中从浮点数映射至区间的两个方法：我们可以把浮点数截尾至紧接的最低区间边界（T编码），
或是可以把浮点数舍入至包围区间之中值（R编码）。类似地，该文描述了从整数表示法重建浮点数的两个方法：我们
可以传回原值映射到的区间的左值（L重建），或是传回区间的中值（C重建）。这样我们有4种编码解码的可行方法：
TL，TC，RL，RC。当然，应避免使用TL及RC，因为这种组合会趋向增加或减少数据中的能量，这通常会产生灾难性
后果。TC的好处在于时间上高效，但也会有些严重问题——无法准确地表示0值（若是0.0f编码，解码后会是一个细小
的正数）。因此RL通常是最好的选择，我们将会在此示范这种方法。
采样频率及键省略：动画数据偏大的原因有三：1.每个关节的姿势含最多10个通道，2.骨骼含大量的关节（人形角色需
100个或以上）3.角色的姿势通常采用高频率采样（例如每秒30帧）。另一方面，我们几乎不能减少高分辨率角色的
关节数目，因此我们无法解决第2个问题，要对付第3个问题，可以做如下两件事。
1.降低整体的采样率：有些动画以每秒15帧导出，效果还是可以的，这么做能使动画数据大小降为一半。
2.省略一些样本：若片段在某个时间区间内，通道数据的变化大约呈线性，那么我们可以省略此区间内除首位以外所有
的样本，然后在运行时，使用线性插值还原删掉了的样本。第2个技术比较复杂，而且需要在每个样本上储存有关时间的
信息。这些额外数据会蚕食我们从一开始通过省略样本而节省的数据量。
动画系统架构：多数由3个分明的软件层所组成
1.动画管道：对于游戏中每个含动画的角色及物体，动画管道为它们取得一个或多个动画片段及对应的混合因子作为输入
然后把这些片段混合后产生一个局部骨骼姿势作为输出、动画管道也会为骨骼计算一个全局姿势，以及生成蒙皮矩阵调色
板供渲染引擎使用。动画管道通常会提供后期处理钩子，以便在生成全局姿势及蒙皮矩阵前可修改局部姿势。此处可将
逆运动学，布娃娃物理，以及其他形式的程序动画施于骨骼之上。
2.动作状态机ASM：游戏角色的动作（站，行，跑，跳等）通常最好建模为有限状态机，此状态机常称为动作状态机。
ASM子系统位于动画管道之上， 并提供以状态驱动的动画接口供所有高层游戏代码之用。ASM确保角色能从一个状态
圆滑地过渡至另一状态。另外，多数动画引擎容许角色身体的不同部分同时做不同独立的事情，例如边跑边瞄准边开火
要实现此功能，可通过状态层使用多个独立的状态机控制单角色。
3.动画控制器：在许多游戏引擎中，玩家与非玩家角色的行为最终是由动画控制器所组成的高级系统所控制的。每个
控制器是特别为管理某个角色行为模式而设的。
动画管道：底层动画引擎所做的运算，构成了把一个输入变换成输出的管道，此管道的各个阶段如下：
1.片段解压及姿势提取：此阶段中每个片段的数据会被解压，并且提取所需时间索引的静态姿势。
2.姿势混合：在此阶段中，通过全身LERP混合，分布LERP混合，及/或加法混合，把输入姿势结合在一起。
3.全局姿势生成：此阶段遍历骨骼层次结构，把局部关节串接以产生骨骼的全局姿势。
4.后期处理：这是一个可选的阶段，使输出最终姿势之前，有机会修改骨骼的局部及/或全局姿势。
5.重新计算全局姿势：许多种类的后期处理都需要全局姿势作为输入，但却只生成局部姿势作为输出。
6.矩阵调色板生成：生成最终全局姿势后，本阶段把每个关节的全局姿势矩阵乘以对应的逆绑定姿势矩阵。本阶段的输出
为供渲染引擎所用的蒙皮矩阵调色板。
共享资源数据：我们必须分清楚共享资源数据和每实体状态信息。
共享数据包括：1.骨骼2.蒙皮网格3.动画片段
每实体数据：片段状态：1.局部时钟 2.播放速率
混合规格：混合规格描述哪些动画片段正在播放，以及这些片段如何混合在一起。主要有两种方式描述片段混合的方式
统一加权平均法及混合树。当使用树状方式时，混合树的结构会视为共享资源，而当中的混合权重则储存为每实例状态数据
分布骨骼关节权重：若应用分部骨骼混合，每个节点对最终姿势的影响力会储存为一组关节权重。
局部姿势：通常是一个SQT数组的数据结构，当中每个SQT对应一个关节，储存成相对于父节点的骨骼最终姿势。
此数组也可能用于储存中间姿势，以作为管道中后期处理阶段的输入及输出。
全局姿势：全局姿势可以是SQT，4*4或4*3的数组，当中每个元素对应一个关节，储存模型空间或世界空间的最终骨骼
姿势，全局姿势可能会用作后期处理的输入。
矩阵调色盘：4*4或4*3矩阵，当中每个元素对应一个关节，储存蒙皮矩阵，供渲染引擎之用。
混合树：有些动画引擎并不是以扁平加权平均描述混合方式的，而是采用混合操作树，我们将会探讨其中原因。
动画混合树是编译理论中的表达式树或语法树的例子，该树内的节点是运算符，而叶节点则是那些运算符的输入。
二元LERP混合：二元线性插值混合从两个输入姿势混合成一个输出姿势，混合权重控制第二个输入姿势显示用于输出
姿势的百分比，

动作状态机：
过渡的参数：1.来源及目标状态2.过渡类型3.持续时间4.缓入/缓出曲线类型5.过渡窗口
控制参数：1.节点搜寻 2.命名变量 3.控制结构 

碰撞及刚体动力学：
刚体是理想化，无限坚硬，不变形的固体物体。动力学是一个过程，计算刚体怎样在力的影响下随时间移动及相互作用
物理系统可以做的事情：1.检测动画物体和静态世界几何之间的碰撞。2.模拟在引力及其他力影响下的自由刚体。3.弹簧
质点系统。4.可破坏的建筑物和结构。5.光线及形状的投射。6.触发体积7.容许玩家拾起刚体8.复杂机器9.陷阱10.带有
逼真悬挂系统的可驾驶载具。11.布娃娃式死亡：真实地混合传统动画及布娃娃物理。12.悬挂道具，半真实的头发/衣服
移动13.布料模拟14.水面模拟及浮力15.声音传播。
物理对游戏的影响：对设计的影响：
1.可预测性，2.调校及控制3.意外行为
对工程的影响：1.工具管道2.用户界面3.碰撞检测4.人工智能5.动画及角色动作6.布娃娃物理7.图形8.网络及多人9.记录及重播
对美术的影响：1.额外的工具及工作流程复杂度2.更复杂的内容3.失控
其他影响：1.跨部门的影响2.对制作的影响
碰撞/物理世界：
碰撞系统通常会通过一个名为碰撞世界的数据结构，管理其所有的可碰撞实体。碰撞世界是专门为碰撞检测而设的游戏
世界完整表达方式。
轴对齐包围盒（AABB）是一个矩形的体积，其6个面都与坐标系统的轴平行。可以方便地由两个点定义：一个点是盒子
在3个主轴上最小的坐标，另一个则是最大的坐标。主要优点在于：1.可以高速地测试和另一AABB是否相交，AABB最大
限制在于，必须一直保持与轴对齐，才能维持这个运算上的优势。
分离轴定理：若能找到一个轴，两个凸形状于该轴上的投影不重叠，就能确定两个形状不相交。
检测凸碰撞：GJK算法
可检测任意凸多胞形，依赖一个称为闵可夫斯基差的几何运算（把A图形中的所有点与B图形的所有点成对相减，得出的
集合{（Ai-Bj）}便是闵可夫斯基差），GJK能一举处理所有凸形状之间的碰撞检测，而不同形状的唯一区别只在于算法
所使用的支持函数。GJK的算法复杂度是O（n*logn），低于O（n2）.
至今我们只考虑两个静止物体的静态相交测试，物体移动时会更加复杂，在游戏中，运动通常是以离散时间步来模拟的。
因此，简单方法是在每个时间步中，将每个刚体的位置和定向当作是静止的，然后把静态相交测试施于这些碰撞世界的
”快照“。若物体的移动速度相对于其尺寸来说不是太块，此方法是可行的。
对于较小的高速移动物体，此方法便会失效，有一个物体，在时间步之间的移动幅度大于其尺度。若我们把相邻的碰撞
世界快照重叠观看，便会注意到该快速移动物体在两个快照之间的像之间有一段空隙，如果另一物体刚好在空隙之间，
便会完全错过碰撞，也可称为”隧穿“。
解决方法：1.扫掠形状：一个形状随时间从某点移动至另一点所形成的形状。例如球体是胶囊体，三角形是三角柱体。
检测相交时，由测试碰撞世界的静态快照，改为测试形状从上一快照的位置及定向移动至当前快照所形成的扫掠形状。
此方法等同对快照间的形状做线性插值。
连续碰撞检测：
CCD技术，目标是对两个移动物体于某时间区间内，求得最早的冲击时间（TOI）。处理隧穿。
CCD算法一般是迭代式的。我们维护每个碰撞体于上个时间步及当前时间的位置及定向。常见的搜寻算法包括保存前进法
向闵可夫斯基和投射光线，以及考虑每对形状特征的最小TOI。
性能优化：
碰撞检测是CPU密集的工作，原因有二。
1.判断两个形状是否相交，所需的计算是非平凡的。
2.多数游戏世界含有大量的物体，随物体数量递增，所需的相交测试会迅速增长。
要检测n个物体之间的相交，蛮力法需要测试逐对物体，造成一个O（n2）算法。然而，实践上有更高效的算法。
碰撞引擎通常会使用某种空间散列方法，空间细分或层次式包围体积，以降低所需的相交测试次数。
时间一致性，空间划分（有多种层阶式的方案可以为优化碰撞检测划分空间，例如八叉树，二元空间分割树，kd树，球体树）
粗略阶段，中间阶段，精确阶段：使用三阶段的方式，缩减每时步中所需检测的碰撞体集合
首先，用粗略的AABB测试判断有哪些物体有机会碰撞，这称为粗略阶段碰撞检测。
然后，检测复合形状的逼近包围体，这称为中间阶段碰撞检测，例如某复合形状由三个球体所构成，该复合形状的包围
体积可以是包围那3个球体的更大球体。复合形状可能含有其他复合形状，因此，一般化来说，复合碰撞体含有一个包围
体积层阶结构。
最后测试碰撞体中个别碰撞原形是否相交。这称为精确阶段碰撞检测。
碰撞查询：最常用的查询类型是碰撞投射，或简称投射（追踪/探查）投射与正常的碰撞检测操作有别，因为投射的实体
并不真正存在于碰撞世界，它完全不会影响世界中的其他物体。
最简单的碰撞投射是光线投射，多数碰撞检测系统可以传回最早的接触，即最近于p0的接触点，又即对应t最小值的点
有些系统也能够传回与光线或线段相交的所有接触点的完整列表。光线投射在游戏中大量使用，例如，我们可能希望询
问碰撞系统，角色A能否直接看见B，为了做出判断，可以简单地从角色A的双眼投射有向线段至角色B的胸口，若光线
触碰角色B，那么A就能看见”B“，武器系统（判断子弹是否命中），玩家机制（角色脚底下是否为地面），人工智能
系统（如视线检测，瞄准，移动查询等），载具系统（把车轮依附地面等）。
形状投射：另一种对碰撞系统的常见查询，是问一个假想凸形状可以沿一有向线段移动多远才会碰到其他物体， 若投射
的体积是球体，则称为球体投射，更一般的情况称为形状投射。
碰撞过滤：
碰撞掩码及碰撞层：常见的碰撞过滤方法之一，就是对世界中的物体进行分类，然后用一个查找表判断某类碰撞体能否
与另一些分类碰撞。
碰撞回调：当碰撞库检测到碰撞时调用回调函数。回调函数可以检查碰撞的具体信息，然后按自己所定的条件决定接受
或拒绝碰撞。
游戏专门的碰撞材质：
游戏开发者通常需要对游戏世界中的物体进行分类，除了用来控制它们如何碰撞（如何使用碰撞过滤），也可以控制其他
效果，如某类物体撞到另一类物体时所产生的声音或粒子效果。
碰撞属性包括：音效，粒子，物体属性（恢复系数，摩擦系数），碰撞过滤信息，以及其他游戏所需的信息。
显示欧拉法：v（t）=r（t），我们只需要简单地把速度乘以时间步，即从米每秒的单位转换为米每帧，然后把1帧所移动
的距离加至当前位置，以求出物体在次帧的新位置。显示欧拉法并不太准确
数值方法的特性：1.收敛性2.阶数3.稳定性
显示欧拉法常出现于游戏中的简单积分工作，当速度接近常数时它能产生最好的结果。然而，通用的动力学模拟并不会
使用显示欧拉法，因为此法误差又高，稳定性又低。对常微分方程求解还有许多方法，包括向后欧拉，中点欧拉，以及
Runge-Kutta方法族。
韦尔莱积分：现在，游戏最常用的常微分方程数值方法大概是韦尔莱积分。此方法实际有两个变种（正常维尔莱及速度
维尔莱）。正常韦尔莱积分非常吸引人，因为它能达至高阶（少误差），相对简单，求值又快，而且能直接使用加速度在
单个步骤中求出位置（而不是一般做法中先用加速度求速度，再用速度求位置）。推导韦尔莱积分公式的方法是把两个
泰勒级数求和，一个是往后的时间，一个是往前的时间。
转动惯量：相当于质量，在旋转动力学中有称为转动惯量的概念，就如同质量代表改变点质量线性速度的难易程度一样。
惩罚性力：另一个碰撞响应方法是，在模拟中引入称为惩罚性力的虚构力。惩罚性力的行为，有如在两个刚互相穿透刚体
的接触点之间，系上一个坚硬的阻尼弹簧。优缺点：优点，容易理解及实现，当有3个或以上的刚体互相穿透时，此法也能
良好工作。缺点，惩罚性力仅影响刚体间的穿透（即相对位置），而非响应相对速度，因此力的方向可能会出乎意料。例如
一辆汽车和货车迎头相撞，由于汽车较货车矮，若仅使用惩罚性力的方法，很容易令惩罚性力垂直向上，而非根据相对
速度形成水平方向的惩罚性力，导致货车车头弹起来，而汽车从下面驶过。
摩擦力：1.静摩擦力，2.滑动摩擦力3.滚动摩擦力（令轮子滚动而不滑动）4.碰撞摩擦力
休止，岛屿及休眠：
休眠条件：1.刚体受支持（指刚体含有3个或以上的接触点）2.刚体的线性及角动量低于预设阈值3.线性及角动量的移动
平均低于预设阈值。4.刚体的总动能低于预设阈值。5.对于将休眠的刚体，可以逐渐减慢其运动，令它能平滑地停止
物理驱动的刚体，若游戏含有刚体动力学系统，那么我们会假设游戏中至少有一些对象会完全由模拟驱动。这些游戏对象
称为物理驱动对象，例如瓦砾碎片，建筑物爆炸，山坡上的滚石，空弹匣及弹壳。
更新模拟：物理模拟当然必须定期更新，通常每帧一次。这不仅设计步进模拟（数值积分，碰撞决议及施以约束），也
需要维持游戏对象和其刚体的联系，若游戏需要对任何刚体施力或冲量，也必须每帧进行，
以下是完整地更新物理模拟所需的步骤：
1.更新游戏驱动刚体，2.更新phantom3.施以力，冲量，并调整约束4.步进模拟5.更新物理驱动的游戏对象6.phantom查询
7.执行碰撞投射查询
安排碰撞查询的时间：1.基于前一帧的状态做决定，2.接受1帧延迟，3.在物理步进后执行查询。
单线程更新，游戏对象分3阶段进行更新：1.于动画运行之前，2.于动画系统计算最终局部姿势及暂定全局姿势之前
3.在物理步进之后。
多线程更新：在另一线程运行物理，其中一个选择是在专用的线程上运行物理/碰撞引擎。这类设计可能引起竞态条件。
若在不合适的时候更新游戏驱动刚体，物理线程可能会在模拟中使用到快过期的位置信息。此问题的解决办法之一是，
安排物理及主线程互相等待——这称为线程同步。线程同步由互斥锁，信号标，或临界区域实现。线程同步通常是相对
高昂的操作，因此我们一般会尽量减少线程间的同步点。以物理引擎来说，我们至少需要两个同步点：一个容许启动该帧
的物理模拟，另一个是当模拟完成后通知主线程。为了降低同步点的数目，策略之一是使用命令队列做线程间通信。
首先，主线程锁定一个临界区域，再写一些命令至队列，然后尽快解锁。
使用碰撞查询会使问题变得复杂，为了令多个线程能同时存取碰撞/物理世界，一些物理引擎会容许对世界分别以读取或
写入模式进行锁定。那么碰撞查询可以在游戏循环中任何时间执行，除非当时物理世界正在更新。
分叉及汇合：使用分叉/汇合架构的好处之一在于，能够从本质上消除所有线程同步问题，主线程如常执行，直至需要
步进物理时，我们把步进的过程fork成独立的线程（最理想的是，为每个处理器核或硬件线程配置一个线程），使步能
尽快执行。当所有线程完成工作后，就要整理合并结果，然后主线程便能如单线程的情况继续进行。
作业模型：若物理SDK容许更新步的个别阶段（积分，碰撞检测，约束求解，CCD等）独立地执行，那么就可以充分利用
到作业模型，作业模型能令每个阶段在最方便的时刻启动，然后主线程在等待物理引擎的工作时能执行其他不相关的工作。
作业模型对碰撞查询（光线/形状投射）更为有用。因为游戏引擎通常只需要在每帧步进物理模拟一次，但可能要在游戏
循环的不同位置进行多次碰撞查询。若使用轻量的作业去执行查询，我们能在任何有需要的时候起动这些作业。另一方面
若碰撞查询只能在帧的某些时候运行，游戏程序员的工作就会变得更困难。
碰撞几何体和渲染几何体不匹配，也会导致一些问题状况，例如，玩家可以从一件物体的细缝或边缘看到目标，但其碰撞
几何体是实心的，所以子弹不能到达目标。解决办法之一是弃碰撞查询，用渲染查询判断光线是否能击中目标。
爆炸：在游戏中，爆炸通常由几个部分组成：一些视觉效果，如火球烟雾，一些音效模仿爆炸的声响及对世界中游戏对象
的影响，往外增长的破坏半径，影响半径范围内的任何对象。

第14章：运行时游戏性基础系统
每个引擎的游戏性软件设计方法都有点不同，然而，多数游戏引擎会以某种形式提供这些主要的子系统。
1.运行时游戏对象模型：抽象游戏对象模型的实现，供游戏设计师在世界编辑器中使用。
2.关卡管理及串流：此系统负责载入及释放下游戏性用到的虚拟世界内容。
3.更新实时对象模型：为了令世界中的游戏对象能有自主的行为，必须定期更新每个对象。
4.消息及事件处理：大多数游戏对象需与其他对象通信，对象间的消息许多时候是用来发出世界状态改变的信号的，此时
就会称这种消息会事件，许多工作室会把消息系统称为事件系统。
5.脚本：使用C/C++等语言来编写高级的游戏逻辑，或会过于累赘。为了提高生产力，提倡快速迭代，以及把团队中
更多工作放到非程序员之手，游戏引擎通常会整合一个脚本语言。如Python或Lua，也可以是图形语言。
6.目标及游戏流程管理：此子系统管理玩家的目标及游戏的整体流程。
运行时对象模型可能是最复杂的，通常它要提供以下大部分功能。
1.动态地产生及消灭游戏对象，2.联系底层引擎系统。3.实时模拟游戏对象行为。4.定义新游戏对象类型5.唯一的对象标识符
6.游戏对象查询，7.游戏对象引用8.有限状态机9.网络复制10.存档及载入游戏，对象持久性（需要一些编程语言的功能
，例如运行时类型识别RTTI，反射，抽象构造）。
运行时对象模型有不同设计，但多数游戏引擎会采用以下两种基本架构风格之一：
1.以对象为中心，2.以属性为中心
多重继承：致命钻石，实现一个又可工作，又易理解，又能维护的多重继承类层次结构，其难度通常超过其得益，因此
多数游戏工作室禁止或严格限制在类层次结构中使用多重继承。
游戏对象描述的序列化：是另一种把游戏对象内部状态表示方式储存至磁盘文件的方法。相比二进制对象技术，往往更
可携及更容易实现。要把某对象序列化至磁盘，就需要该对象产生一个数据流，当中要包含足够的细节，供日后重建
原本的对象，要从磁盘的数据反序列化至内存。C#和Java都提供标准机制序列化对象至XML文本格式，以及其反序列化。
可惜C++没有标准化的序列化机制。然而，在游戏业行内或行外，也开发了许多成功的C++序列化系统。
把对象序列化至磁盘以及从磁盘反序列化，通常可以实现为以下两种机制之一：
1.在基类加入一对虚函数，如SerializeOut（）和SerializeIn（），然后在每个派生类实现这两个函数，说明如何序列化该类
2.实现一个C++类的反射系统，那么就可以开发一个通用的系统去自动序列化任何包含反射信息的C++对象。
反射是C#及其他一些语言的术语，概括地说，反射数据描述了类在运行时的内容。这些数据所储存的信息包括类的名称，
类中的数据成员，每个数据对象的类型，每个成员位于对象内存映像的偏移，此外，它也包含类的所有成员函数信息。
若能获取任何一个C++类的反射信息，开发通用的对象序列化系统是挺简单的一回事。
然而，C++反射系统中最棘手的地方在于，生成所有相关类的反射数据。其中一个方法是，使用#define对类中每个数据
成员抽取相关的反射数据，然后让每个派生类重载一个虚函数以返回该类相关的反射数据。也可以手工地为每个类编写
反射的数据结构。除了属性信息，序列化数据流中的每个对象总是会包含类/类型的名字或唯一标识符。类标识符的作用
是，当把对象反序列化至内存时，用来实例化适当的类。类标识符可以是字符串，字符串散列标识符，或是其他类唯一
标识符。遗憾的是，C++并没有提供以字符串或标识符去实例化的方法，类的名称必须在编译时决定。
生成器及类型架构：二进制对象映像和序列化格式都有一个致命要害，都是由对象类型的运行时实现所定义的，因此世界
编辑器需要深入知道游戏引擎运行时才能运作。为了解耦游戏世界编辑器和运行时代码，我们可以把实现无关的游戏对象
描述抽象出来。对于世界组块数据文件中的每个游戏对象，我们储存多一点数据，这组数据常称为生成器。生成器是游戏
对象的轻量，仅含数据的表示方式，可用于在运行时实例化及初始化游戏对象。它含有游戏对象在工具方的类型标识符，
也包含一个简单键值对表描述游戏对象的属性初始值。
定位器在游戏中有多种用途：1.定义人工智能角色的兴趣点，2.定义一组坐标轴去令多个动画能完美地同步播放。
3.定义粒子效果或音效的起始位置。4.定义赛道中的航点。
生成器及类型架构的好处：简单，富弹性，健壮性。
游戏世界的加载和串流：（LSR）载入并驻留数据，堆栈分配器，
能在玩家游玩时同时加载完整世界组块，关键是异步文件IO。
现代游戏引擎支持这类无缝世界的技术称为串流。世界串流可以用多种方式实现，其中有两个重要目标：a.在玩家参与
正常的游戏性任务时加载数据；b.用某些方式管理内存，使玩家在游戏过程中不断加载，卸载数据也不会导致内存碎片。
这种粗粒度的世界串流方式有一个问题，那就是它对世界组块的大小设下麻烦的限制，游戏中所有的组块的大小必须大致
相同，每个组块需要足够大以填充3个缓冲区之一，而又不能超载。
此问题解决办法之一是，采用更细粒度的内存分割方式。原来我们会串流较大的内存组件，取而代之，我们把游戏中每个
游戏资产都切割为相同大小的数据块。然后我们使用一个以块为单位，基于内存池的内存分配系统，按需加载及卸载这些
资源文件，而无须担心造成内存碎片。
对象生成的内存管理：当游戏世界载入至内存后，我们需要管理世界中动态对象的生成。多数游戏引擎都含某形式的游戏
对象生成系统，负责管理实例化组成游戏对象的一个或多个类，以及当游戏对象不再需要后负责其销毁过程。由于动态
分配可能很慢，所以我们必须花一些功夫确保分配过程尽量高效。又由于游戏对象会有不同的大小，为它们做动态分配
可能导致内存碎片，最后形成过早的内存不足情况。
对象生成的离线内存分配（简单的完全禁止再游戏途中动态分配内存，容许游戏世界组块动态加载和卸载，但载入组块后
立即生成所有动态游戏对象，然后就不再创建和销毁游戏对象了）（游戏对象守恒定律——加载世界组块后便不能创建或
销毁游戏对象）缺点方面，此法对游戏设计师造成颇严重的限制。但是完全避免了内存碎片
面对内存碎片问题，由于不同类型的游戏对象占用不同内存用量，不能使用无碎片分配器——池分配器。
以下几个常见方法：为每个对象类型设内存池。若每个对象类型的实例能保证占用相同的内存量，我们可以考虑为每个
对象类型使用独立的池分配器。实际上，我们只需要为相同大小的对象共享一个池分配器，那么相同的对象类型也会
用到同一个分配器。
小块内存分配器，内存重定位。

游戏存档：
游戏存档系统与世界载入组件相似，后者也能从磁盘或记忆卡加载游戏世界状态。但两者的需求有些不同，所以通常会把
两者作为独立的系统。世界组块含有世界中动态对象的初始状态，但也包含所有静态世界元素的完整描述。大部分静态信
息（如背景网格和碰撞数据），往往消耗许多磁盘空间。因此，世界组块有时候由多个磁盘文件组成，而世界组块所涉及
的数据总量通常很庞大。
另一方面，游戏存档必须储存世界中游戏对象的状态信息。然而，它不需要储存从世界组块数据就能得知的重复信息。
例如，我们无须把静态几何储存至游戏存档中。游戏存档也不需要储存每个游戏对象的所有状态细节。存档可以完全忽略
不影响游戏性的对象。对于其他对象而言，也可能只需要储存部分状态信息。只要玩家不能分辩存档时及读档后的世界
状态有何分别（或是那些分别不影响玩家），这就是一个成功的游戏存档系统。因此，游戏存档文件往往较世界组块文件
细小得多，而且会更注重压缩及省略数据。尤其是要把大量游戏存档储存至上一代游戏机中的细小记忆卡时，细小的存档
文件更显重要。
储存点：游戏存档的方式之一是，限制只能在某些指定地方存档，这些地点称为储存点。
任何地方皆可存档：容许玩家在游戏过程中几乎任何地方储存游戏的状态，此功能必然导致存档文件显著变大，因此与
游戏性相关的每个游戏对象位置和内部状态都需要储存下来，并且在之后载入并回复原来的状态。
缩减游戏存档的数据量的方法之一是，省略一些无关的游戏对象及一些无关的细节。
许多游戏引擎都大量使用指针，因为指针是实现对象引用最快，最高效并最容易使用的方式。
然而，程序员对指针小心翼翼，有些游戏团队会转用更精密的对象引用类型，其原因包括希望采用更安全的编程惯例，
或是认为有必要，若游戏引擎在运行时利用重定位来消灭内存碎片，就不能使用简单的指针。我们可能需要一种对重定位
健壮的对象引用类型，或是需要手动修正每个指向重定位内存块的指针。
智能指针也可以帮助管理对象生命周期，方法是通过与其他智能指针合作来判定对象的引用个数，此技术称为引用计数。
Boost C++模板库提供6个不同种类的智能指针：
1.scoped_ptr:指向单个对象且该对象只有一个拥有者的指针。
2.scoped_array:指向一组对象且那组对象只有一个拥有者的指针。
3.shared_ptr:指向一个对象的指针，该对象的生命周期由多个拥有者共享。
4.shared_array:指向一组对象的指针，该组对象的生命周期由多个拥有者共享。
5.weak_ptr:指向一个对象的指针，但它不拥有该对象，也不会自动销毁该对象（该对象的生命周期须由一个shared_ptr管理）
6.intrusive_ptr:其实现引用计数的方法是，假设指向的对象会维护该引用计数，侵入式指针非常有用，因为它们所占的空间
和原始C++指针相同，另一个原因是它们能直接地从原始指针建构。
正确地实现智能指针类可能是一个艰巨的任务，读者看一看Boost的智能指针文档便能了解其难度，当中要解决多个问题。
1.智能指针的类型安全性。2.令智能指针可以使用不完整的类型。3.在异常出现时保持正确的智能指针行为。
4.在运行时的成本可能很高。
句柄：在很多方面的行为都像智能指针，但它更易实现并且较少出现问题。基本上，句柄就是某全局句柄表的整数索引，
而句柄表则是储存指向引用对象的指针。要创建一个句柄，只需简单地用对象的地址去搜寻句柄表，并把结果索引储存
在句柄中，要对句柄解引用，则只需把句柄作为索引去读取句柄表，并把该位置的指针解引用。
句柄有机会引用过时对象，解决方案之一是，在每个句柄中中加入唯一的对象标识符。
游戏对象查询：
每个游戏引擎至少要提供几个在运行时搜寻对象的方法，我们称这些方法为游戏对象查询。最简单的查询种类是用
对象的唯一标识符来查找他。以下是游戏开发者可能需要的游戏对象查询例子：
1.找出玩家视线范围内的所有敌人角色。2.对某类型的所有游戏对象进行迭代。3.找出所有血量少于80%的可破坏游戏对象
4.向所有在爆炸影响半径范围内的游戏对象做出伤害 5.对子弹弹道或其他抛射体路径中的对象进行由近至远的迭代。
以下列举了一些可用于加速某类游戏对象查询的专门的数据结构。
1.以唯一标识符搜寻游戏对象（游戏对象的指针或句柄可储存于以唯一标识符为键的散列表或二叉查找树）
2.对合乎某条件的所有对象进行迭代（可预先以多个条件排序（假设我们能预知所需的条件））
3.搜寻抛射体路径或对某目标点视线内的所有对象。（查询通常会利用碰撞系统实现）
4.搜寻某区域或半径范围内的所有对象。（用一些空间散列数据去储存游戏对象。可能是置于整个世界之中的简单平面
栅格，也可以是更精密的方法，如四叉树/八叉树/kd树等）
游戏对象更新系统对计算机科学来说，是一个动态，实时，基于代理的计算机模拟。
游戏对象更新系统也和离散事件模拟有关。
批次式更新带来很多性能效益，包括但不限于：
1.最高的缓存一致性，2.最少的重复计算 3.减少资源再分配 4.高效的流水线。
游戏对象可按需增加更多更新阶段，但要小心，因为每次遍历所有游戏对象并调用个对象的虚函数，其开销可能很高。
而且，并非所有游戏对象都需要所有更新阶段，遍历不需要某个阶段的对象纯粹浪费CPU时钟周期。一个降低遍历成本
的方法是管理多个游戏对象链表，每个链表代表一个更新阶段。一个对象如需在某个阶段中更新，就加到相应的链表，
以此避免遍历不关注某个更新阶段的对象。
桶式更新：当存在对象间的依赖时，便要轻微调整上述的阶段式更新技巧。因为对象间的依赖性可能抵触更新次序的规则
对象间的依赖可以想象为多个依赖树组成的树林。

对象状态及“差一帧”延迟：理论上，所有游戏对象的状态是瞬间及并行地从时间t1更新至t2的，然而，实际上，只会
逐个对象更新，比如遍历游戏对象并逐一调用它们的更新函数。
”所有游戏对象的状态在更新循环之前和之后是一致的，但在更新途中可能是不一致的“。
在更新循环中，游戏对象的不一致状态是混淆和bug的主要来源。即使游戏业界从业人员也是如此。
对象状态缓存：解决这个问题的方案之一是把游戏对象按桶分类。
一个能改善一致性的办法如下。更新时，不要就地覆写新的状态到原来的矢量，而是保留之前的状态矢量Si（t1），并把
新的状态写到另一个矢量Si（t2）。这带来两个益处：1.任何对象都可安全地查询其他对象的之前状态，不受对象更新次序
影响，2.就算是在更新的过程中，它保证永远有一个完全一致的状态Si（t1），暂时称该技术为状态缓存。
状态缓存还有一个好处，可以通过线性地向前后两个状态插值，得出该时间段任何时刻的状态近似值。
该技术的缺点就是比就地更新状态多耗1倍的内存，而且该技术也只能解决一部分问题。在之前状态在t1是完全一致的，但
在t2的新状态仍然可能不一致。
加上时戳：为改善游戏对象状态的一致性，一个简单低成本的方法是为对象加上时戳。那么就能轻易分辨游戏对象的状态
是在之前还是当前时间。任何查询其他对象的代码，应用断言或明确地检查对方的时戳，以确保取得的状态资讯是恰当的。
加上时戳并不能解决同一桶内对象的不一致问题。但我们可以设一个全局或静态变量反映目前正在更新哪一个桶。
假设每个对象都知道它们置于哪个桶，就可以断言查询对象不应置于现时正在更新的桶，以防查询到不一致的状态。

为并行设计：
使游戏对象模型本身并行：众所周知，使游戏对象模型并行是很困难的，当中有几个原因，通常，游戏对象间会大量相互
依赖，游戏对象也可能和多个引擎子系统所产生的数据互相依赖。此外，游戏对象会与其他游戏对象交流，有时候在更新
循环中会多次交流，而交流的模式是不可预期且易受玩家输入所影响的。这使游戏对象在多线程中更新变得困难。例如，
对象间通信须使用线程同步机制，在效能角度上这通常是不容许的。并且，直接读取其他对象的状态矢量，便不能传送
游戏对象到副处理器的隔离内存去更新。话虽如此，理论上仍然可以并行更新游戏对象，为使它更符合实践，我们应谨慎
设计整个对象模型，保证对象不能直接查看其他游戏对象的状态矢量。所有对象交流须使用消息传递。我们需要一个高效
的系统传递消息，无论对象是分隔在不同内存还是不同CPU物理核，有些研究采用分布式编程语言编写游戏对象模型。
这些语言提供内置的并行及消息传递功能，也比C/C++之类的语言更高效地处理线程的上下文切换，这些语言的编程惯用
法也可以协助防止程序员”打破规则“，使并发式，分布式，多代理的设计恰当及高效。
与并发的引擎子系统接口：大部分游戏团队仍然使用单线程的游戏对象及旧式的游戏循环，他们把注意力集中于使游戏
对象依赖的许多低阶子引擎系统并行化。这么做会有更大的成本效益，相比于游戏对象模型，低阶引擎子系统才是性能
关键。低阶子系统必会在每帧处理高容量的数据，而游戏对象模型所需的CPU资源通常比较小。这是80-20规则的实际应用例子
要把同步非批次代码改为异步批次形式，最棘手的是决定在游戏循环中何时启动请求及何时等待并使用请求的结果。
1.请求能在多早启动：越早启动请求，就越有机会能在实际需要结果时完成工作。这样，主线程就不会闲着等待异步请求
的结果，优化CPU的使用率。因此，我们应该分析每个请求，找出能有足够资讯启动它的帧内最早时刻，并在那一刻启动它。
2.在需要请求的结果前可以等多久：或许我们可以等到更新循环稍后的地方继续执行下半部分。或许我们可以容忍1帧的滞后
，并使用上一帧的结果更新本帧的对象状态。

事件和消息泵：游戏本质上是事件驱动的，事件是游戏过程中发生，希望关注的事情。发生爆炸，玩家被敌人看见，拾取
补血包等都是事件。游戏通常需要一些方法做两件事——当事件发生时通知关注该事件的对象，以及安排那些对象回应所
关注的事件——后者称为事件处理。
静态函数类型绑定带来的问题：编译器在编译期并不知道将会运行哪个函数实现，只有在运行时得知目标对象的类型，
才能运行适当的实现。我们称虚函数是静态类型，因为给定一个对象类型，编译器能知道应该调用哪个实现。
（虽然虚函数的调用在运行时确定，但虚函数本身及其与类的关联是在编译时确定的。在编写代码时，虚函数是与特定的
类关联的，而且函数的签名（返回类型和参数）也是在编译时知道的。这些信息是静态的，它们在编译时就已经确定了。
因此，从类型的角度来看，虚函数仍然是静态类型的一部分。）
静态函数类型绑定带来的问题在于，它在某程度上降低了实现的弹性。
我们真正想要的事件处理程序，是动态函数类型的后期绑定。（C#的delegate原生支持）
把事件封装成对象：
事件实质上由两部分组成：类型（爆炸，朋友受伤，玩家被发现，拾起补血包等）以及参数。参数为事件提供细节（爆炸
会造成多少伤害？哪个朋友受伤？玩家在哪里被发现？）我们可以把这两部分封装成对象。
有些游戏引擎称这些为消息或命令，而不称为事件。实际上，事件对象通常不止这么简单，例如，我们可能会从一个事件
根类派生不同的事件类型。而参数也可能实现为链表或动态分配的数组，以容纳任意数量的参数，并且参数可以是不同的
数据类型。
把事件（或消息）封装为对象有许多好处：
1.单个事件处理函数：意味着我们仅需要单个虚函数处理所有事件类型。
2.持久性：事件对象有一点和函数调用不相似，函数的参数在调用返回后就离开了作用域，但事件对象把其类型及参数
储存为数据。因此，事件对象含有持久性，可储存于列队，稍后才做处理，也可复制及广播至多个接收者等。
3.盲目地转发事件：对象可以转发它收到的事件至另一对象，而不需要知道事件的内容。

我们有多种方法分辨不同事件类型，在C/C++中最简单的方法是使用一个全局的枚举，把每个事件类型映射至一个唯一整数：
此方法的优点在于简单及高效（因为整数通常能极快地读/写及比较），然而，它也有3个弊病（1.游戏中所有事件类型都
要集中在一起，这可视为破坏封装的一种形式，2.事件类型是硬编码的，意味着新的事件类型不可通过数据驱动的方式
来定义。3.枚举仅是索引，它们是次序相关的）
另一个事件类型编码方法是使用字符串，此方法是完全自由形式的，只要想一个名字就能加入新的事件类型。但它有几个
问题，包括有较大的机会产生事件名称冲突，也有机会因拼错字而导致不能正常运作，字符串消耗的内存也较多，而且
比较字符串较整数来得慢。为了减少内存和提高性能，可以用字符串散列标识符来代替原始字符串。虽然如此，基于字符串
或字符串标识符的事件系统富极高弹性，而且它们本质上支持数据驱动。

事件参数：事件的参数通常与函数的参数很相似，都是用来提供可能对接收者有用的事件相关信息的。事件参数可以用
多种方式实现。另一个方法是把事件参数储存为variant的集合。variant是一种数据对象，可储存多于一种数据类型。
variant通常会储存当前的数据类型以及数据本身。
事件处理器：
当游戏对象接收到一个事件/消息/命令，它需要以某种方式做出回应，此过程称为事件处理，并通常实现称为事件处理器
的函数或脚本段落。事件处理器通常是一个原生的虚函数或脚本函数，它能处理所有类型的事件。此情况下，函数通常
包含某种switch语句或一串if/elseif语句，以处理不同类型的，可能接收到的事件。
Microsoft Foundation Class（MFC）是Windows GUI工具集，它含有一个著名的消息映射，可以在运行时把Windows
消息绑定至任何非虚或虚函数。这种做法避免了在单个根类中声明所有可能的Windows消息处理器，同时也能避免使用
一个巨大的switch语句。
职责链：游戏对象几乎总是依赖于另一些游戏对象。总括而言，我们可以把游戏类型之间的关系想象为一个或多个关系图
事件排队的好处：1.控制事件处理的时机 2.往未来投递事件的能力 3.事件的优先次序
带来的问题：1.增加了事件系统的复杂度 2.深度复制事件及参数 3.为队列中的事件做动态内存分配 4.调试困难
即时传递事件带来的问题：可能引致非常深的调用堆栈。
数据驱动事件/消息传递系统：
在脚本模型下，设计师实质上等同于程序员（但脚本相比工程师用的语言，功能较有限，较容易学习，希望更少出错）
视觉化编程的优缺点：容易使用，有大量错误检测，工具的帮助和提示可以引导用户渐进学习。流程图式的图形用户接口
也有一些缺点，包括：开发，调试，维护这种系统的成本高，增加了复杂性，甚至影响进度的bug。
脚本：主要目的在于让用户控制及定制应用软件程序的行为。在游戏引擎的语境中，脚本语言可供程序员和非程序员开发
新游戏，或是定制一个现存的游戏。
数据定义语言：在于让用户创建及填充数据结构，这些数据将会供引擎读取。
运行时脚本语言：运行时脚本语言在运行时的引擎上下文执行。通常用于扩展或定制引擎游戏对象模型及/或其他引擎系统
的硬编码功能。
程序语言特性：
直译式与编译式语言：编译式语言的源码由编译器翻译成机器码，然后这些机器码直接在CPU上执行，而直译式语言的源
码，可以在运行时直接解析，或是先编译为平台无关的字节码，然后这些字节码在虚拟机中执行。虚拟机如同一个假想
CPU的模拟，而字节码就如同此CPU可执行的机器码，虚拟机的好处在于它比较容易移植至几乎所有硬件平台，并可嵌入
至一个宿主应用程序。此弹性带来的最大代价是运行速度，虚拟机执行字节码的速度通常比原生CPU执行机器码要慢得多。
命令式语言：在命令式语言中，程序是由指令序列所组成的，每个指令执行一个操作或是读/写内存中的数据。C/C++是命令式语言。
声明式语言：声明式语言描述要做什么但不指明如何取得结果。如何执行取决于语言实现。Prolog是声明式语言的例子。置标语言，如HTML和TeX，也可归类为声明式语言。
函数式语言：在技术上可算是声明式语言的子集，其目的是完全避免使用状态。程序由一组函数所定义。
过程式语言与面向对象语言。
反射式语言：在反射式语言中，数据类型，数据成员布局，函数，类层次结构关系等信息可以在运行时于系统取得，
在非反射式语言中，大部分这些元信息只能在编译时获取，只有非常小的部分能供运行时取用。C#是反射式语言的例子。
游戏脚本语言的典型特性：1.直译式（多数游戏脚本语言是由虚拟机直译的，而非编译的，基于弹性，可移植性，快速迭代的考虑）
2.轻量：多数游戏脚本语言是为嵌入式系统设计的。因此，它们的虚拟机比较简单，而且内存消耗也比较少。
3.支持快速迭代：每当修改原生源程序码，我们必须重新编译及链接程序；游戏也需要先关掉再重启，才能看到改动后的
效果。另一方面，脚本代码改动后，通常可以非常快速地看到改动的效果。有些游戏引擎容许即时重新载入脚本，而无须
关掉游戏。有一些引擎可能需要关掉再重启。但无论是哪一种方式，修改脚本至看到改动效果的时间，通常比原生语言源
程序要短得多。
4.方便易用：脚本语言通常会根据具体游戏的需求来定制，我们可以提供一些功能令常见的任务简单，直觉及较难出错。
Lua是著名且流行的脚本语言，能容易地整合至应用软件，包括游戏引擎。Lua官网称Lua是“游戏界脚本语言之首”
Lua的关键优点包括：
1.健壮及成熟，2.优良文档，3.卓越的运行时性能，4.可移植性，5.为嵌入设备而设计，6.简单，强大，可扩展，7.免费
Lua是动态类型语言，意味着变量没有类型，只有值才有类型。Lua的基本数据结构是表，也即是关联数组。表实质上是
一个键值对的列表，优化了以值索引的能力。
Lua提供一个C语言的方便接口，令Lua虚拟机可以调用及操作用C编写的函数。
Lua把代码段当作第一类对象，Lua程序也可以处理这些代码段。代码可以用源码方式执行，也可以预编译为字节码格式。
所以虚拟机可以执行一个含Lua代码的字符串，如同该代码被编译进原来的程序中。Lua支持高级强大的编程功能，包括
协程。合作式多任务的一种简单形式，每个线程必须明确地交出CPU供其他线程执行。
Lua也有一些隐患，例如，其富弹性的函数绑定机制令我们可以（且很容易）重新定义一些重要的全局函数去执行完全不
同的任务。
Python是过程式，面向对象，动态类型脚本语言，为容易使用，与其他程序语言整合，高度弹性而设计。和Lua相似，
Python也常用作游戏脚本语言。
Python的最优功能包括：
1.清晰可读的语法 2.反射性语言 3.面向对象 4.模块化 5.基于异常的错误处理 6.包罗万象的标准库 7.可嵌入 8.详尽的文档
Python主要的数据结构是list和dictionary，前者是线性可索引的序列，后者是键值对的表。
Python支持鸭子模式，是指一种动态类型风格，当中函数接口决定了对象的类型。鸭子类型在某些方面和C++的模板元
编程相似，虽然鸭子类型大概是更富弹性的，因为调用者和被调用者的绑定是动态在运行时形成的。
脚本所需的架构：1.回调脚本（在此架构下，引擎的主要功能大部分都是以原生编程语言硬编码的，只有某些关键的小功
能设计称可定制的。这些部分通常实现为钩子函数，或称为回调，都是指用户提供一个函数供引擎调用，借以做出定制。）
事件处理器脚本：其实只是一种特殊的钩子函数，其作用是令游戏对象回应游戏世界发生的相关事件，或是回应引擎本身
的事件，或是回应引擎本身的事件。许多游戏引擎容许以脚本或原生语言编写事件处理器。
以脚本扩展游戏对象类型或定义新类型：有些脚本语言可以用脚本扩展原来由原生语言实现的游戏对象类型。
组件或属性脚本，脚本驱动的引擎系统，脚本驱动的游戏。
运行时游戏脚本语言的功能：
许多游戏脚本语言的主要目的是用于实现游戏性功能，而达成此目的的方法通常是修改及定制游戏的对象模型。
1.对原生编程语言的接口  
2.游戏对象句柄：脚本函数通常需要与游戏对象互动，而游戏对象本身可能是部分或全部由引擎原生语言所实现的。原生
语言的对象引用机制未必能用于脚本语言。因此，我们需要一个可靠的方法让脚本引用游戏对象。其中一个方法是，在
脚本中以不透明的数值型句柄来引用对象。脚本对象可以用多种方法取得对象句柄。
数值型句柄的优点是简单，能容易地应用于支持整数数据的脚本语言。
使用字符串作为对象句柄也会有缺点，字符串比整数标识符占用更多的内存空间，而且字符串长度可变，需要动态内存
分配来复制它们。比较两个字符串也是较慢的操作。字符串散列标识符可以克服以上大部分问题。
发送事件：容许脚本处理引擎产生的游戏事件，无疑是一项强大的功能，另一更强大的功能是，从脚本代码产生事件，
并把事件发送至引擎或其他脚本。
有限状态机脚本：游戏编程中许多问题可以用有限状态机（FSM）解决。因此，有些引擎把FSM的概念建立在核心游戏
对象模型中。在这些引擎中，每个游戏对象可以有一个至多个状态，并且每个状态会含有更新函数，事件处理函数等。
多线程脚本：多数脚本系统通过合作式多任务来提供并行性。指脚本会一直执行，直至它主动交出执行权。相反，抢占式
多任务可以在任何时候中断正在执行的脚本，令其他脚本得以执行。
