拷贝构造和拷贝赋值有什么区别呢？
如果是新对象，就是构造，如果是已有成员就是赋值。

条款1：视C++为一个语言联邦
C++带有一些面向对象特征还有异常，模板，STL
今天的C++是个多重泛型编程语言，支持过程形式，面向对象形式，函数形式，泛型形式，元编程形式。
C++主要的次语言：C（区块，语句，预处理器，内置数据类型，数组，指针），Object-Oriented C++（包括构造函数
析构函数，封装继承多态，virtual函数（动态绑定）），Template C++（C++的泛型编程）STL（容器迭代器算法函数对象）
对内置C类型而言，pass-by-value比pass-by-reference高效，当你从C part of C++移往Object-Oriented C++，由于用户
自定义的构造函数和析构函数，pass-by-reference-to-const往往更好，运用TemplateC++尤其如此，因为你甚至不知道
所处理的对象的类型，跨入STL你就会了解，迭代器和函数对象都是在C指针之上塑造出来的，所以对STL的迭代器和函数对象
而言，旧式的C pass-by-value再次适用。
因此，C++并不是一个带有一组守则的一体语言：它是从四个次语言组成的联邦政府，每个次语言都有自己的规约。

条款2：尽量以const，enum，inline替换#define
或许替换”宁可以编译器替换预处理器“比较好，因为或许#define不被视为语言的一部分，那正是问题所在，
例如#define ASPECT_RATIO 1.653，记号名称AS...也许从未被编译器看见，也许在编译器开始处理源码之前就被预处理
器移走了，于是记号有可能没进入记号表内。语言常量肯定会被编译器看到，当然就会进入记号表内。
使用常量可能比使用#define导致较小量的码，因为预处理器”盲目地将宏名称ASPECT_RATIO“替换为1.653
可能导致目标码出现多份1.653.因为预处理器会将代码中所有AS...都盲目替换为1.653，而常量不会
当我们以常量替换#define时，有两种特殊情况：1.定义常量指针，由于常量定义式通常被放在头文件内，因此有必要
将指针声明为const，string对象通常比其前辈char*-based合宜。
2.class专属常量，为了将常量的作用域限制于class内，你必须让它成为class的一个成员。
为确保此常量至多只有一份实体，你必须让它成为一个static成员。无法用#define创建一个class专属常量，因为#defines
并不重视作用域，一旦宏被定义，它就在其后的编译过程中有效，也不能用来提供封装性，const成员可以被封装。
旧时编译器不允许static成员在其声明式上获得初值，”in-class“也只允许对整数常量进行。如果编译器不支持，
你可以将初值放在定义式：class{static const double FudgeFactor；}（位于头文件）
 const double C...::FudgeFactor = 1.35；（位于实现文件）
唯一例外是当你在class编译期间需要一个class常量值，例如上述的数组声明式中，这时候你的编译器不允许，可改用
所谓的”the enum hack“补偿做法，其理论基础是：”一个属于枚举类型的数值可权充ints被使用“
例：class GamePlayer{private: enum{NumTurns = 5}; int scores[NumTurns];};
enum hack值得我们认识，第一，enum hack的行为某方面说比较像#define而不像，const，有时候这正是你想要的。
例如取一个const的地址合法，但是取enum的地址就不合法，而取#define的地址也不合法。
如果你不想让别人获得一个pointer或reference指向你的某个整数常量，enum可以帮你实现这个约束。
优秀的编译器不会为”整数型const对象“设定另外的存储空间（除非你创建pointer或reference指向该对象），
不够优秀的编译器却可能如此，Enums和#defines一样绝不会导致非必要的内存分配。
第二，纯粹是为了实用主义，是template metaprogramming模板元编程的基础技术。
无论何时写出宏，需要为宏中所有实参加上小括号，不然会遭遇麻烦。
template inline函数可以获得宏带来的效率以及一般函数的所有可预料行为和类型安全性。
template<typename T>
inline void callWithMax(const T& a,const T& b){f(a>b?a:b);}
#include仍然是必需品，#ifdef/#ifndef也继续扮演控制编译的重要角色。
总结：1.对于简单常量，最好以const对象或enums替换#defines，2.对于形似函数的宏，最好改用inline函数替换#defines

条款3：尽可能使用const
它允许你指定一个语义约束，而编译器会强制实施这项约束，它允许你告诉编译器和其他程序员某值应该保持不变。
可以用它在classes外部修饰global或namespace作用域中的常量，或修饰文件，函数或区块作用域中被声明为
static的对象，也可以用它修饰classes内部的static和non-static成员变量，面对指针，你也可以指出指针自身，指针所指物或两者都是const
const语法：如果关键字const出现在*左边，表示被指物是常量（常量指针const*），右边，表示指针自身是常量（指针常量*const）。
STL迭代器系以指针为根据塑模出来，所以迭代器作用就像是T*指针。声明迭代器为const就像声明指针为const一样。
const最具威力的用法是面对函数声明时的应用，在一个函数声明式中，const可以和函数返回值，各参数，函数自身产生关联
令函数返回一个常量值，可以降低因客户操作错误而造成的意外，又不至于放弃安全性和高效性。
为什么会返回一个const对象，举例：客户可能会返回（a*b）=c；，很难想象有人竟然会对a*b的乘积做赋值，O.0。
除非有需要改动参数或local对象，否则将它们声明为const。
const实施于成员函数重要的原因：1.使class接口比较容易被理解，2.使操作const对象成为可能。
const 的两个流行概念：bitwise constness，和logical constness
b阵营的人相信（成员函数只有在不更改对象之间的任何成员变量时才可以说是const），但是许多成员函数虽然
不十分具备const性质却能通过bitwise测试，更具体：一个更改了指针所指物的成员函数虽然不是const，但如果
只有指针隶属于对象，那么称此函数为bitwise const 不会引发编译器异常
l阵营主张，一个const成员函数可以修改它所处理的对象内的某些bits，但只有客户端检测不出的情况下才可以
解决办法：利用C++的一个const相关的摆动场，mutable，释放掉non-static成员变量中的bitwise constness约束。


总结：1.将某些东西声明为const可帮助编译器侦测出错误用法，const可被施加于任何作用域内的对象，
函数参数，函数返回列表，成员函数本体
2.编译器强制实施bitwise constness，但你编写程序时应该使用“概念上的常量性”
3.当const和non-const成员函数有着实质等价的实现时，领non-const版本调用const版本可避免代码重复。

条款4：确定对象被使用前已先被初始化
C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前。初始化的发生时间更早，发生于这些成员的default
构造函数被自动调用之时。构造函数的一个较佳写法是，使用所谓的member initialization list（成员初值列）替换赋值动作：
例如： ABEntry::ABEntry(const std::string& name,const std::string& address):theName(name),theAddress(address){}
这个构造函数和不使用成员初值列（使用赋值）的最终结果相同，但通常效率较高。（dafault构造函数的一切浪费了）
对大多数类型而言，先调用default构造函数再调用copy assignment操作符，单只调用一次copy构造函数是比较高效的。
规定总是在初值列中列出所有成员变量，以免还得记住那些成员变量可以无需初值。
有些情况下即使面对的成员变量属于内置类型，也一定得使用初值列。是的，如果成员变量是const或references，它们就
一定需要初值，不能被赋值。为避免需要记住成员变量何时必须在成员初值列中初始化，何时不需要，总是使用成员初值列。
许多classes拥有多个构造函数，每个构造函数都有自己的成员初值列，如果这种classes存在许多成员变量和/或base classes
多份成员初值列的存在就会导致不受欢迎的重复（在初值列内）和无聊的工作（对程序员而言）。这种情况下可以将一些成员
变量的初始化操作移动到一个私有函数中，并在每个构造函数中调用这个函数。
static对象，其寿命从被构造出来直到程序结束为之，因此stack和heap-based都被排除，包括global，namespace，class
函数内，file作用域内被声明为static的对象都是local static。其他是非non-local static 对象，程序结束时static对象被自动
销毁，也就是它们的析构函数会在main（）结束时被自动调用。
编译单元是指产出单一目标文件的那些源码，基本上它是单一源码文件加上其所含入的头文件。
C++对“定义于不同编译单元内的non-local static 对象”的初始化次序并无明确定义。在其最常见形式，也就是多个编译
单元内的non-local static 对象经由“模板隐式具现化”形成，不但不可能决定正确的初始化次序，甚至往往不值得寻找
“可决定正确次序”的特殊情况。一个小小的设计便可完全消除这个问题，将每个non-local static对象搬到自己的专属
函数内（该对象在此函数内被声明为static），这些函数返回一个reference指向它所含的对象。然后用户调用这些函数，
而不直接指涉这些对象。换句话说，non-local static对象被local static 对象替换了。
这个手法的基础在于：C++保证，函数内的local static对象会在“该函数被调用期间”“首次遇上该对象之定义式”时
被初始化。所以如果你以“函数调用”替换“直接访问non-local static对象”，你就获得了保证，保证你所获得的那个
reference 将指向一个历经初始化的对象。更棒的是，如果你从未调用non-local static对象的“仿真函数”，就绝不会
引发构造和析构成本，真正的non-local static 对象可没这等便宜。
任何一种non-const static 对象，不论它是local或non-local，在多线程环境下“等待某事发生”都会有麻烦。处理麻烦的
一种做法是：在程序的单线程启动阶段手工调用所有的reference-returning函数，这可消除于初始化有关的“竞速形势”
为避免在对象初始化之前过早地使用它们，你需要做三件事。第一，手工初始化内置性non-menber对象。第二，使用成员
初值列对付对象的所有成分。最后，在“初始化次序不确定性”氛围下加强你的设计。

2.构造/析构/赋值运算：
条款5：了解C++默默编写并调用哪些函数
注意，编译器产出的析构函数是个non-virtual，除非这个class的base class自身声明有virtual析构函数。
由于声明了一个构造函数，编译器于是不再为它创建default构造函数。
条款6：若不想使用编译器自动生成的函数，就该明确拒绝
可以将函数操作符声明为private，一般而言这个做法并不绝对安全，member和friend函数还是可以调用的。
将连接期错误移至编译期是可能的（而且是好事，因为越早检测出越好）只要将copy构造函数和copy assignment操作符
声明为private就可以办到，但不是在HomeForSale自身，而是在一个专门为了阻止copying动作而设计的base class内。
class  Uncopyable{
protected：		//允许derived对象析构和构造
      Uncopyable() {}
      ~Uncopyable(){}
private:
      Uncopyable(const Uncopyable&);		//阻止copying
      Uncopyable& operator= (const  Uncopyable&);
};
class   HomeForsale:  private   Uncopyable   {	//class 不再声明
	...				//copy构造函数或
}；					//copy assign. 操作符
这行得通，只要任何人——甚至是menber函数或friend 函数——尝试拷贝Home...对象，编译器试着生成一个copy构造
函数和一个copy assignment操作符，而正如条款12所说，这些函数的“编译器生成版”会尝试调用其base class的对应
兄弟，那些调用会被编译器拒绝，因为base class的拷贝函数是private。
请记住：为驳回编译器自动提供的机能，可将相应的成员函数声明为private并且不予实现，使用像Uncopyable这样的base
class 也是一种做法。
条款7：为多态基类声明virtual析构函数
当派生类对象经由一个基类指针被删除，而基类带着一个非虚析构函数，其结果未有定义——实际执行时通常发生的是对象
的derived成分没被销毁。而基类被销毁，造成了诡异的“局部销毁”对象，形成资源泄漏，败坏之数据结构，在调试器上
浪费许多时间的绝佳途径。消除问题的做法很简单：给base class一个虚析构函数，此后删除派生类对象会如你想要的那般
想实现一个虚函数，必须携带一个虚表指针（用来在运行期决定哪一个虚函数被调用），指向一个由函数指针构成的数组
（虚表）——编译器在其中寻找适当的函数指针。
虚函数的实现细节不重要，重要的是内含虚函数，其对象的体积会增加。因为其他语言的对应物并没有vptr，因此也就不再
可能把它传递至（或接受自）其他语言所写的函数，除非明确补偿vptr，属于实现细节，不再具有移植性。
因此，无端地将所有classes的析构函数声明为虚函数，就像从未声明它们为虚函数一样，都是错误的，许多人的心得是，
只有当class内含至少一个虚函数，才为它声明虚析构函数。
如果基类的析构函数不是虚函数，或者派生类不会被用作多态类型（即不会通过基类指针或引用删除派生类对象），那么
派生类的析构函数可以不是虚函数。此外，如果派生类是一个终结类（即不会被其他类继承），那么它的析构函数也
不需要是虚函数。
请记住：带有多态性质的基函数应该声明一个虚析构函数，如果class带有任何虚函数，它就应该有一个虚析构函数
类的设计目的如果不是作为基类使用，或不是为了具备多态性，那就不应该声明为虚析构函数。

条款8：别让异常逃离析构函数
如果在析构函数过程中报错发出异常有两个解决办法：1.如果close抛出异常就结束，通常通过调用abort完成。
2.吞下因调用close而发生的异常。这些办法都没有吸引力，问题在于两者都无法对“导致close抛出异常”的情况做出反应
一个较佳的策略是重新设计DBConn接口，使其客户有机会对可能出现的问题作出反应。
如果某个操作可能在失败时抛出异常，而又存在某种需要必须处理该异常，那么这个异常必须来自析构函数以外的某个函数
因为析构函数吐出异常就是危险，总会带来“过早结束程序”或“发生不明确行为”的风险。由客户自己调用的close并不会
对他们带来负担，而是给他们一个处理错误的机会，否则他们没机会响应。如果他们不认为这个机会有用，可以忽略，依赖
DBConn析构函数去调用close，如果真有错误发生，而且DBConn吞下该异常或结束程序，客户没立场抱怨，毕竟他们放弃了
请记住：1.析构函数绝对不要吐出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后
吞下它们（不传播）或结束程序。2.如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个
普通函数（而非在析构函数中）执行该操作。
条款9：绝不在构造和析构过程中调用虚函数。
如果基函数的构造函数内包含虚函数，派生类调用构造函数时，先调用基函数，而派生类的函数几乎必然取用局部成员变量
但是成员变量尚未初始化，这是一张通往不明确行为和彻夜调试大会串的直达车票。“要求使用对象内部尚未初始化的成分”
是危险的代名词，C++不让你走这条路。更根本的原因，在派生类对象的基函数构造期间，对象类型是基类，而不是派生类
不只虚函数被编译器解析至基类，若使用运行期间类型信息例如（动态类型转换，typeid）也会把对象视为基类。对象在
派生类构造函数开始执行前不会称为一个派生类对象。相同道理适用于析构函数，一旦派生类析构函数开始执行，对象内的
派生类对象便呈现未定义值，所以C++视它们彷佛不再存在。
侦测“构造函数或析构函数运行期间是否调用虚函数”并不总是这般轻松，如果Tran..有多个构造函数，每个都需执行某些
相同工作，那么避免代码重复的一个优秀做法是把共同的初始化代码放进一个初始化函数init内。
唯一能够避免此问题的做法就是：确定你的构造函数和析构函数都没有调用virtual函数，而它们调用的所有函数也都服从
同一约束。
其他方案可以解决这个问题（如何确保一有Tran（基）继承体系上的对象被创建，就会有适当版本的log（虚函数）被调用呢）
一种做法是在class Transaction内将logTransaction函数改为non-virtual，然后要求派生构造函数传递必要信息给tran构造函数
而后那个构造函数可安全调用非虚log...。
换句话说，你无法使用虚函数从基类向下调用，在构造期间，你可以借由“令派生类将必要的构造信息向上传递至基类构造函数”
比起在成员初值列内给予base class所需数据，利用辅助函数创建一个值传给base class构造函数往往比较方便（可读）。
令此函数为static，也就不可能意外指向“初期未成熟之buyTransaction”对象内尚未初始化的成员变量。这很重要，因为
“那些成员变量处于未定义状态”，所以“在base class构造和析构期间调用的虚函数不可下降至派生类”

条款10：令operator=返回一个reference to *this
重载运算符（也包括+=，-=，*=...）
注意：这只是个协议，并无强制性，如果不遵循它，代码一样可以通过编译。
条款11：在operator=中处理“自我赋值”
Widget& Widget::operator=(const Widget& rhs)
{
	if(this == &rhs) return *this;
	delete pb;
	pb = new Bitmap(*rhs.pb);
	return *this;
}这样做行得通，前一版operator=不仅不具备自我赋值安全性， 也不具备异常安全性，这个新版本仍然存在异常方面的麻烦
在operator=函数内手工排序语句（确保代码不但“异常安全”而且“自我赋值安全”）的一个替代方案，使用所谓的copy
and swap技术。和“异常安全性”有密切关系，令人高兴的是，让operator=具备“异常安全性”往往自动获得“自我
赋值安全”的回报。
将“copying动作”从函数本体移至“函数参数构造阶段”却可令编译器有时生成更高效的代码。
请记住:1.确保当对象自我赋值时operator=有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址，精心周到
的语句顺序，以及copy-and-swap。   2.确定任何函数如果操作一个以上的对象，而其中多个对象是同一对象时，其行为仍
然正确。
条款12：复制对象时勿忘其每一个成分。
如果你为class添加一个成员变量，你必须同时修改copying函数以及任何非标准形式的operator=。继承类的copying函数
看起来好像复制了继承类的每一样东西，但是它所继承的基类成员变量复件（副本），那些成员变量未被复制。
复制每一个成分：1.复制所有的local成员变量 2.调用所有的base classes内的适当的copying函数。
使用copy assignment操作符调用copy构造函数是不合理的，因为这就像试图构造一个已经存在的对象，这件事如此荒谬
乃至于根本没有相关语法。
如果你发现你的copy构造函数和copy assignment操作符有相近的代码，消除重复代码的做法是，建立一个新的成员函数
给两者调用。这样的函数往往是private而且常被命名为init。这个策略可以安全消除copy构造函数和copy assignment操作
符之间的代码重复。
请记住：1.copying函数应该确保复制“对象内的所有成员变量”及“所有base class成分” 2.不要尝试以某个copying函数
实现另一个copying函数。应该将共同机能放进第三个函数中，并由两个copying函数共同调用。

3.资源管理
C++程序中最常使用的资源就是动态分配内存，但内存只是你必须管理的众多资源之一。其他常见的资源还包括文件描述器
互斥锁，图形界面中的字型和笔刷，数据库连接，以及网络sockets。重要的是，当你不用时，要还给系统。
条款13：以对象管理资源
“以对象管理资源”的两个关键想法：
1.获得资源后立即放进管理对象内，2.管理对象运用析构函数确保资源被释放
auto_ptrs有一个不寻常的性质：若通过copy构造函数或copy assignment操作符复制它们，它们会变成null，而复制所得
的指针将获取资源的唯一拥有权。auto_ptr被销毁时会自动删除它所指之物，所以一定要注意别让多个auto_ptr同时指向
同一对象。如果真是那样，对象会被删除一次以上，而那会使你的程序搭上“未定义行为”的快速列车。
STL容器不能使用auto_ptr，auto_ptr的替代方案是“引用计数型智慧指针”。所谓RCSP也是个智能指针，持续追踪共有
多少对象指向某笔资源，并在无人指向它时自动删除该资源。无法打破环状引用。
auto_ptr和shared_ptr不支持在其析构函数内做delete[]动作，Boost里的boost::scoped_array,boost::shared_array 
classes，它们提供你要的行为。
createInvestment返回的raw pointer简直是对资源泄漏的一个死亡邀约，因为调用者极易在这个指针上忘记调用delete，
即使使用auto_ptr,tr1::shared_ptr来执行delete，他们首先必须记得将createInvestment的返回值储存于智能指针对象内
请记住：1.为防止资源泄漏，请使用RAII对象，他们在构造函数中获得资源并在析构函数中释放资源
2.两个常被使用的RAII classes分别是 tr1::shared_ptr,auto_ptr前者通常是较佳选择，因为其copy行为比较直观。若选择
auto_ptr，复制动作会使它（被复制物）指向null。	RAII“资源获取就是初始化”
条款14：在资源管理类中小心coping行为
当一个RAII对象被复制，会发生什么，大多数时候你会选择一下两种可能：
1.禁止复制：将copying操作声明为private
2.对底层资源祭出“引用计数法” 3.复制底部资源   4.转移底部资源的拥有权 
请记住：1.复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为
2.普遍而常见的RAII class copying 行为是：抑制copying，施行引用计数法。

条款15：在资源管理类中提供对原始资源的访问
1.APIs往往要求访问原始资源，所以每个RAII class 应该提供一个“取得其所管理之资源”的办法。
2.对原始资源的访问可能经由显示转换或隐式转换。一般而言显示转换比较安全，隐式转换对客户比较方便。
条款16：成对使用new和delete时要采用相同形式
如果你用new[]，必须在相应的delete表达式中也是用[]。如果你在new表达式中不使用[],一定不要在相应的delete表达式中使用[]。
条款17：以独立语句将newed对象置入智能指针
请记住：以独立语句将newed对象储存于智能指针内，如果不这么做，一旦异常抛出，可能导致难以察觉的资源泄漏。

4.设计与声明
条款18：让接口容易被正确使用，不易被误用
tr1::shared_ptr 有一个特别好的性质是：它会自动使用它的“每个指针专属的删除器”，因而消除另一个潜在的客户错误：
所谓的“cross-DLL problem”。这个问题发生于“对象在动态连接程序库DLL中被new创建”，却在另一个DLL内被delete
销毁。在许多平台上，这一类“跨DLL之new/delete成对运用”会导致运行期错误。tr1::shared_ptr没有这个问题，因为它
缺省的删除器是来自“tr1::shared_ptr”诞生所在的那个DLL的delete。返回的tr1共享指针可被传递至其他任何DLLs，无需
在意“cross-DLL problem”。这个指向Stock的tr1::shared_ptr会追踪记录“当Stock的引用次数变成.时该调用的那个DLL's delete”
Boost的共享 指针是原始指针的两倍大，以动态分配内存作为簿记用途和“删除器之专属数据”
请记住：1.好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质。
2.“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。
3.“防止误用”的办法包括建立新类型，限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。
4.tr1::shared_ptr支持定制型删除器。可防范DLL问题，可被用来自动解除互斥锁。
条款19：设计class犹如设计type
1.新的type的对象应该如何被创建和删除？2.对象的初始化和对象的赋值该有什么差别？3.新的type对象如果被passed by
value（以值传递），意味着什么？4.什么是新type的”合法值“5.你的新type需要配合某个继承图系吗？6.你的新type需要
什么样的转换？7.什么样的操作符和函数对此新type而言是合理的？8.什么样的标准函数应该驳回？ 9.谁该取用新的type的成员？
10.什么是新type的”未声明接口“ 11.你得新type有多么一般化？ 12.你真的需要一个新type吗？
条款20：宁以pass-by-reference-to-const替换pass-by-value（调用一次花费太多时间和内存）
一般而言，你可以合理假设”pass-by-value并不昂贵“的唯一对象就是内置类型和STL的迭代器和函数对象。至于其他任何
东西都请遵守本条款的忠告，尽量以pass-...替换passbyvalue。并且可避免切割问题。内置类型及STL的迭代器和函数对象
pass-by-value往往比较合适。
从120页看不懂。
条款22：切记将变量声明为private。protected并不比public更具封装性。
